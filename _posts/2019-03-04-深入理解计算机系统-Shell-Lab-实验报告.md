---
layout: post
title: "深入理解计算机系统 Shell Lab 实验报告"
comments: true
description: "深入理解计算机系统 Shell Lab 实验报告"
keywords: "Shell Lab, 深入理解计算机系统, CSAPP"
---

# 介绍

本实验，通过写一个简单的 Unix Shell 程序，来熟悉进程控制和信号的概念。

首先去[官网](http://csapp.cs.cmu.edu/3e/labs.html)下载 lab，将 lab 上传至服务器后，完成下面的步骤：

1. 执行 `tar xvf shlab-handout.tar` 解压缩。
2. 执行 `make` 编译并连接一些测试例程。
3. 在 `tsh.c` 中输入你的姓名。

`tsh.c(tiny shell)` 中已经提供了一个简单的 Unix Shell 的框架。完成 `tsh.c` 中剩余的空函数。

关于 Unix Shell 的用处，在书中已经有详细介绍，这里就不过多说。对于我们实现的 tiny shell 来说，例如执行：

```shell
tsh> jobs
```

tiny shell 就会执行内置的 jobs 命令。

```shell
tsh> /bin/ls -l -d
```

表示在前台执行 ls 程序，其中 ls 程序的入口，`int main(int argc, char *argv[])` 的参数内容如下：

1. argc == 3
2. argv[0] == "/bin/ls"
3. argv[1] == "-l"
4. argv[2] == "-d"

值得注意的是，Unix Shell 支持 job control，job control 允许用户将 job 的执行，在前台与后台之间来回切换，还能改变一个 job 中进程的状态(running, stopped, or terminated)。

# 关于 tsh.c

我们实现的 tiny shell(tsh.c) 应该有如下功能：

1. 提示符为 "tsh> "
2. 输入命令应该包括 name 和 argument，以空格隔开。如果 name 是内置命令，tsh 必须立即处理。如果非内置命令，tsh 将 name 当做可执行文件的路径，将该文件加载进 job 中执行(ps：此处 job 也指 tsh 创建的子进程)
3. tsh 不用支持管道(|)和 I/O 重定位(< 和 >)
4. 键入 ctrl-c (ctrl-z) 后，将会发送 SIGINT (SIGTSTP) 信号到当前的前台 job，以及这个 job 的子进程。如果没有前台 job，信号无效
5. tsh 支持 & 符号
6. 每个 job 使用 tsh 指定的 process ID 或者 job ID 来区分，"%5" 指 JID 为 5，"5" 指 PID 为 5
7. tsh 支持一下内置命令：quit(退出 shell)；jobs(列出所有的后台 job)；bg <job> (向 job 发送 SIGCONT 信号，并后台重启)；同理，fg <job> 指前台重启
8. tsh 应该回收所有的僵尸子进程。如果一个 job 接受到一个信号，但没有 catch 住，tsh 应该打印出 job 的 PID 和该信号的描述

# 测试工具

## Reference solution

lab 提供了 tshref 来作为解题参考，也就是 tsh 完成后，同样的输入，在 tsh 和 tshref 中应该有相同的输出。

## Shell driver

lab 提供的 sdriver.pl 将 tiny shell 运行为一个子进程，向它发送 trace file 中指定的命令和信号。

键入一下命令查看帮助。

```shell
unix> ./sdriver.pl -h
Usage: sdriver.pl [-hv] -t <trace> -s <shellprog> -a <args>
Options:
    -h Print this message
    -v Be more verbose
    -t <trace> Trace file
    -s <shell> Shell program to test
    -a <args> Shell arguments
    -g Generate output for autograder
```

例如，执行 `./sdriver.pl -t trace01.txt -s ./tsh -a "-p"` 或者 `make test01`。

为了方便，lab 中提供了 `tshref.out`，里面是执行所有 trace file 的标准输出答案。

# 思路提示

1. 仔细阅读书中 Chapter 8 (Exceptional Control Flow)
2. 利用好 trace file，从简单的 trace01.txt 开始
3. 灵活运用 `waitpid()` 的  WUNTRACED 和 WNOHANG 参数
4. 在实现相关 signal handler 时，使用 "-pid" 替换 "pid" 作为 `kill()` 的参数，将 SIGINT 和 SIGTSTP 信号发送给所有的前台进程。
5. 注意在 `waitfg()` 和 `sigchld_handler()` 之间的任务分配。建议在 `waitfg()` 中使用带有 `sleep()` 的无限循环；在 `sigchld_handler()` 中只执行对 `waitfg()` 一次的调用。虽然也有其他解决办法，比如在 `waitfg()` 和 `sigchld_handler()` 都调用 `waitpid()`，但是在 `sigchld_handler()` 里执行回收更加简单。
7. 在 `eval()` 中，执行 `fork()` 前，父进程必须用 `sigprocmask()` 来阻塞 SIGCHLD 信号，然后解除阻塞，最后在调用 `addjob()` 前再次执行 `sigprocmask()`。因为子进程继承了父进程的阻塞向量，在需要的时候也应该解除 SIGCHLD 信号的阻塞。父进程在 `sigchld_handler()` 中执行回收时，由于阻塞了 SIGCHLD，也有效的避免了 **race**。
9. 当你在标准 Unix Shell 中运行 tiny shell 时，tiny shell 是运行在前台进程组的，如果 tiny shell 创建一个子进程，这个子进程默认也会成为前台进程组的一员。因为键入 ctrl-c 会发送 SIGINT 信号到前台进程组的所有进程，那么 tiny shell 以及它创建的子进程，都会收到 SIGINT 信号，这显然是不对的。解决办法就是：在 `fork()` 后，`execve()` 前，子进程调用 `setpgid(0, 0)`，会将自己放进一个新的进程组，而不是存在于前台进程组。这样就保证了前台进程中始终只有一个 tiny shell。当你键入 ctrl-c，tiny shell 会 catch 到 SIGINT 信号，并将信号转发给相应的前台 job。

# 评估方案

总分 90 分，一共 16 个 trace 文件，每个 5 分；代码风格占 10 分，包括注释和检查系统调用的返回值。



