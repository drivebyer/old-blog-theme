---
layout: post
title: "深入理解计算机系统 Shell Lab 实验报告"
comments: true
description: "深入理解计算机系统 Shell Lab 实验报告"
keywords: "Shell Lab, 深入理解计算机系统, CSAPP"
---

# 介绍

本实验，通过写一个简单的 Unix Shell 程序，来熟悉进程控制和信号的概念。

首先去[官网](http://csapp.cs.cmu.edu/3e/labs.html)下载 lab，将 lab 上传至服务器后，完成下面的步骤：

1. 执行 `tar xvf shlab-handout.tar` 解压缩。
2. 执行 `make` 编译并连接一些测试例程。
3. 在 `tsh.c` 中输入你的姓名。

`tsh.c(tiny shell)` 中已经提供了一个简单的 Unix Shell 的框架。完成 `tsh.c` 中剩余的空函数。

关于 Unix Shell 的用处，在书中已经有详细介绍，这里就不过多说。对于我们实现的 tiny shell 来说，例如执行：

```shell
tsh> jobs
```

tiny shell 就会执行内置的 jobs 命令。

```shell
tsh> /bin/ls -l -d
```

表示在前台执行 ls 程序，其中 ls 程序的入口，`int main(int argc, char *argv[])` 的参数内容如下：

1. argc == 3
2. argv[0] == "/bin/ls"
3. argv[1] == "-l"
4. argv[2] == "-d"

值得注意的是，Unix Shell 支持 job control，job control 允许用户将 job 的执行，在前台与后台之间来回切换，还能改变一个 job 中进程的状态(running, stopped, or terminated)。

# 关于 tsh.c

我们实现的 tiny shell(tsh.c) 应该有如下功能：

1. 提示符为 "tsh> "
2. 输入命令应该包括 name 和 argument，以空格隔开。如果 name 是内置命令，tsh 必须立即处理。如果非内置命令，tsh 将 name 当做可执行文件的路径，将该文件加载进 job 中执行(ps：此处 job 也指 tsh 创建的子进程)
3. tsh 不用支持管道(|)和 I/O 重定位(< 和 >)
4. 键入 ctrl-c (ctrl-z) 后，将会发送 SIGINT (SIGTSTP) 信号到当前的前台 job，以及这个 job 的子进程。如果没有前台 job，信号无效
5. tsh 支持 & 符号
6. 每个 job 使用tsh指定的 process ID 或者 job ID 来区分