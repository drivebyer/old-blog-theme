---
layout: post
title: "深入理解计算机系统 Shell Lab 实验报告"
comments: true
description: "深入理解计算机系统 Shell Lab 实验报告"
keywords: "Shell Lab, 深入理解计算机系统, CSAPP"
---

# 介绍

本实验，通过写一个简单的 Unix Shell 程序，来熟悉进程控制和信号的概念。

首先去[官网](http://csapp.cs.cmu.edu/3e/labs.html)下载 lab，将 lab 上传至服务器后，完成下面的步骤：

1. 执行 `tar xvf shlab-handout.tar` 解压缩。
2. 执行 `make` 编译并连接一些测试例程。
3. 在 `tsh.c` 中输入你的姓名。

`tsh.c(tiny shell)` 中已经提供了一个简单的 Unix Shell 的框架。完成 `tsh.c` 中剩余的空函数。

关于 Unix Shell 的用处，在书中已经有详细介绍，这里就不过多说。对于我们实现的 tiny shell 来说，例如执行：

```shell
tsh> jobs
```

tiny shell 就会执行内置的 jobs 命令。

```shell
tsh> /bin/ls -l -d
```

表示在前台执行 ls 程序，其中 ls 程序的入口，`int main(int argc, char *argv[])` 的参数内容如下：

1. argc == 3
2. argv[0] == "/bin/ls"
3. argv[1] == "-l"
4. argv[2] == "-d"

值得注意的是，Unix Shell 支持 job control，job control 允许用户将 job 的执行，在前台与后台之间来回切换，还能改变一个 job 中进程的状态(running, stopped, or terminated)。

# 关于 tsh.c

我们实现的 tiny shell(tsh.c) 应该有如下功能：

1. 提示符为 "tsh> "
2. 输入命令应该包括 name 和 argument，以空格隔开。如果 name 是内置命令，tsh 必须立即处理。如果非内置命令，tsh 将 name 当做可执行文件的路径，将该文件加载进 job 中执行(ps：此处 job 也指 tsh 创建的子进程)
3. tsh 不用支持管道(|)和 I/O 重定位(< 和 >)
4. 键入 ctrl-c (ctrl-z) 后，将会发送 SIGINT (SIGTSTP) 信号到当前的前台 job，以及这个 job 的子进程。如果没有前台 job，信号无效
5. tsh 支持 & 符号
6. 每个 job 使用 tsh 指定的 process ID 或者 job ID 来区分，"%5" 指 JID 为 5，"5" 指 PID 为 5
7. tsh 支持一下内置命令：quit(退出 shell)；jobs(列出所有的后台 job)；bg <job> (向 job 发送 SIGCONT 信号，并后台重启)；同理，fg <job> 指前台重启
8. tsh 应该回收所有的僵尸子进程。如果一个 job 接受到一个信号，但没有 catch 住，tsh 应该打印出 job 的 PID 和该信号的描述

# 测试工具

## Reference solution

lab 提供了 tshref 来作为解题参考，也就是 tsh 完成后，同样的输入，在 tsh 和 tshref 中应该有相同的输出。

## Shell driver

lab 提供的 sdriver.pl 将 tiny shell 运行为一个子进程，向它发送 trace file 中指定的命令和信号。

键入一下命令查看帮助。

```shell
unix> ./sdriver.pl -h
Usage: sdriver.pl [-hv] -t <trace> -s <shellprog> -a <args>
Options:
    -h Print this message
    -v Be more verbose
    -t <trace> Trace file
    -s <shell> Shell program to test
    -a <args> Shell arguments
    -g Generate output for autograder
```

例如，执行 `./sdriver.pl -t trace01.txt -s ./tsh -a "-p"` 或者 `make test01`。

为了方便，lab 中提供了 `tshref.out`，里面是执行所有 trace file 的标准输出答案。

# 提示

1. 仔细阅读书中 Chapter 8 (Exceptional Control Flow)
2. 利用好 trace file，从简单的 trace01.txt 开始
3. 灵活运用 `waitpid()` 函数的  WUNTRACED 和 WNOHANG 参数
4. 在实现相关 signal handler 时，使用 "-pid" 替换 "pid" 作为 `kull()` 的参数，将 SIGINT 和 SIGTSTP 信号发送给所有的前台进程。
5. 注意在 `waitfg()` 和 `sigchld_handler()` 函数之间的任务分配。建议在 `waitfg()` 中使用带有 `sleep()` 的无限循环；在 `sigchld_handler()` 中只执行对 `waitfg()` 一次的调用。虽然也有其他解决办法，比如在 `waitfg()` 和 `sigchld_handler()` 都调用 `waitpid()`，但是在 `sigchld_handler()` 里执行回收更加简单。
7. In eval, the parent must use sigprocmask to block SIGCHLD signals before it forks the child,and then unblock these signals, again using sigprocmask after it adds the child to the job list by calling addjob. Since children inherit the blocked vectors of their parents, the child must be sure to then unblock SIGCHLD signals before it execs the new program.The parent needs to block the SIGCHLD signals in this way in order to avoid the race condition where the child is reaped by sigchld handler (and thus removed from the job list) before the parent calls addjob.
8. Programs such as more, less, vi, and emacs do strange things with the terminal settings. Don’t run these programs from your shell. Stick with simple text-based programs such as /bin/ls, /bin/ps, and /bin/echo.
9. When you run your shell from the standard Unix shell, your shell is running in the foreground process group. If your shell then creates a child process, by default that child will also be a member of the foreground process group. Since typing ctrl-c sends a SIGINT to every process in the foreground group, typing ctrl-c will send a SIGINT to your shell, as well as to every process that your shell created, which obviously isn’t correct. Here is the workaround: After the fork, but before the execve, the child process should call setpgid(0, 0), which puts the child in a new process group whose group ID is identical to the child’s PID. This ensures that there will be only one process, your shell, in the foreground process group. When you type ctrl-c, the shell should catch the resulting SIGINT and then forward it to the appropriate foreground job (or more precisely, the process group that contains the foreground job)



