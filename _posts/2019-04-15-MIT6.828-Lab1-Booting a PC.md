---
layout: post
title: "MIT6.828 操作系统 Lab1:Booting a PC"
comments: true
description: "MIT6.828 操作系统 Lab1:Booting a PC"
keywords: "Lab, 6.828, MIT"
---

# 介绍

这个实验分为 3 部分，第一部分用来熟悉 x86 汇编，QEMU 和 PC 启动过程。第二部分实操 6.828 kernel 的启动加载。第三部分，探索 6.828 kernel 的初始化。

## 软件设置

实验使用 git 版本控制系统，仓库地址为 [](https://pdos.csail.mit.edu/6.828/2018/jos.git)，使用命令将仓库 clone 到本地。

在实验开始之前需要安装 `qemu` 和 `gcc`，参考链接为[tool page](https://pdos.csail.mit.edu/6.828/2018/tools.html)。

# Part 1: PC Bootstrap

这个作业的目的是介绍 x86 汇编语言和 PC 启动过程，并熟悉 QEMU 和 QEMU/GDB 调试。

## Getting Started with x86 assembly

下面是实验中提供的一些关于汇编的资源：

1. [PC Assembly Language](https://pdos.csail.mit.edu/6.828/2018/readings/pcasm-book.pdf)
2. [Brennan's Guide to Inline Assembly](http://www.delorie.com/djgpp/doc/brennan/brennan_att_inline_djgpp.html)
3. [Intel® 64 and IA-32 Architectures Software Developer Manuals
](https://software.intel.com/en-us/articles/intel-sdm)

这三份资源，第一个是对汇编语言的入门教材，由于这个课程是用的是 GUN assembler，而不是 NASM assenbler，所以提供了第二份资料来学习 Intel 与 AT&T 汇编语法的差别。

第三份资料则是最权威的 Intel 开发手册。

## Simulating the x86

qemu 内置的 debug 功能受限，我们将换用 gdb 进行调试。

编译上面 clone 下来的仓库代码，注意前提是安装好了实验指定版本的 qemu 和 gcc。

编译完 JOS kernel 后，执行 `make qemu`，最终 qemu 窗口显示如下文本:

```c
Booting from Hard Disk...
6828 decimal is XXX octal!
entering test_backtrace 5
entering test_backtrace 4
entering test_backtrace 3
entering test_backtrace 2
entering test_backtrace 1
entering test_backtrace 0
leaving test_backtrace 0
leaving test_backtrace 1
leaving test_backtrace 2
leaving test_backtrace 3
leaving test_backtrace 4
leaving test_backtrace 5
Welcome to the JOS kernel monitor!
Type 'help' for a list of commands.
K>
```

**Booting from Hard Disk...** 后所有的输出都来自于 JOS 内核。

JOS 内核目前只有两条命令 **help** 和 **kerninfo**。

## The PC's Physical Address Space

PC 的物理地址布局通常如下:

```
+------------------+  <- 0xFFFFFFFF (4GB)
|      32-bit      |
|  memory mapped   |
|     devices      |
|                  |
/\/\/\/\/\/\/\/\/\/\

/\/\/\/\/\/\/\/\/\/\
|                  |
|      Unused      |
|                  |
+------------------+  <- depends on amount of RAM
|                  |
|                  |
| Extended Memory  |
|                  |
|                  |
+------------------+  <- 0x00100000 (1MB)
|     BIOS ROM     |
+------------------+  <- 0x000F0000 (960KB)
|  16-bit devices, |
|  expansion ROMs  |
+------------------+  <- 0x000C0000 (768KB)
|   VGA Display    |
+------------------+  <- 0x000A0000 (640KB)
|                  |
|    Low Memory    |
|                  |
+------------------+  <- 0x00000000
```

世界上第一台 PC，是基于 16 位都 Intel 8088 处理器，但是那时的地址线有 20 bit，所以能寻址到 2^20 byte(1MB)，所以早期 PC 的内存地址范围为 0x00000000 ~ 0x000FFFFF(1MB)，图中的 Low Memory 是早期 PC 能够使用的 RAM 范围。

从 0x000A0000 到 0x000FFFFF (1024KB - 640KB = 384KB)这个范围，主要是为了硬件保留的，其中最重要的是 BIOS ROM 这块区域，早期 PC 的 BIOS 是 ROM，现代的 PC 已经将其换成可更新的 Flash Memory 了。

BIOS 主要负责系统初始化，例如激活 Video Card 和检查内存容量等。完成初始化后，BIOS 将操作系统从软盘、硬盘、CD 或者网络加载进来，然后将控制权转交给操作系统。

虽然后来的 80286 和 80386 处理器分别已经将寻址范围扩大到 16MB 和 4GB，为了保持软件向后兼容，PC 架构仍然保留了上图中 0x00000000 ~ 0x00100000 中的布局结构。因为这些历史原因，RAM 被分割成了两部分:

1. low/conventional memory(0x00000000 ~ 0x000A0000 640KB)
2. extended memory(0x00100000 ~ )

这两部分被 0x000A0000 ~ 0x00100000 这块区域分割开来，我们将这块区域叫做 “hole”。另外，在 32 位 PC 架构的机器上，高地址处通常为 PCI 设备保留着。

最近的一些 x86 处理器已经能够支持超过 4GB 的 RAM 了。这种情况下，BIOS 应该预留第二个 “hole”，它位于高地址区域。因为 JOS 的设计受限，只会使用到上图中前 256MB 的物理内存空间，所以从现在开始，假设 PC 只有 4GB 的物理内存空间。

## The ROM BIOS

在这部分，将会学习使用 QEMU 的 debug 功能来探索 IA-32 兼容计算机的启动过程。

首先启动两个 shell，都进入 lab 目录，其中一个执行 `make qemu-nox-gdb`，另一个执行 `make gdb` 后，显示如下:

```
wu@wu-insparition-5421:~/6.828/lab$ make gdb
gdb -n -x .gdbinit
GNU gdb (Ubuntu 8.1-0ubuntu3) 8.1.0.20180409-git
Copyright (C) 2018 Free Software Foundation, Inc.
License GPLv3+: GNU GPL version 3 or later <http://gnu.org/licenses/gpl.html>
This is free software: you are free to change and redistribute it.
There is NO WARRANTY, to the extent permitted by law.  Type "show copying"
and "show warranty" for details.
This GDB was configured as "x86_64-linux-gnu".
Type "show configuration" for configuration details.
For bug reporting instructions, please see:
<http://www.gnu.org/software/gdb/bugs/>.
Find the GDB manual and other documentation resources online at:
<http://www.gnu.org/software/gdb/documentation/>.
For help, type "help".
Type "apropos word" to search for commands related to "word".
+ target remote localhost:26000
warning: No executable has been specified and target does not support
determining executable automatically.  Try using the "file" command.
warning: A handler for the OS ABI "GNU/Linux" is not built into this configuration
of GDB.  Attempting to continue with the default i8086 settings.

The target architecture is assumed to be i8086
[f000:fff0]    0xffff0:	ljmp   $0xf000,$0xe05b
0x0000fff0 in ?? ()
+ symbol-file obj/kern/kernel
(gdb) 
```

下面这行:

```
[f000:fff0]    0xffff0:	ljmp   $0xf000,$0xe05b
```

是 GDB 对第一条指令的反汇编，从中我们有如下推断:

1. IBM PC 从物理地址 0x000ffff0(稍后会介绍这个地址的计算方法) 处开始执行，这个位置位于 ROM BIOS 里面
2. PC 开始执行时，CS = 0xf000，IP = 0xfff0
3. 第一条指令是 jmp 指令，它跳转到 CS = 0xf000 IP = 0xe05b 处

这种做法源自于 Intel 对 8088 处理器的设计，因为 BIOS 永远都在 0x000f0000 ~ 0x000fffff 这个范围内，这就保证了只要 PC 一接通电源，BIOS 能第一时间控制到 PC，这是很关键的，因为在接通电源的瞬间，RAM 中除了 BIOS 没有其他的软件能够执行。

如上面所说，PC 在接通电源后，处理器进入 Real Mode(实模式)，将 CS 和 IP 分别设置成 0xf000 和 0xfff0。由于 PC 刚启动后，处理器处于 Real Mode(实模式)，在实模式下，地址转换使用下面的公式:

> Physical Address = 16 * Segment(CS) + offset(IP)

所以，第一条指令的地址计算为: 0xf000 * 16 + 0xfff0 = 0x000ffff0。

然而 0x000ffff0 距离 BIOS 的范围结束(0x00100000)只有 16bytes，由于 16bytes 所做的事情有限，所以第一条 jmp 指令跳到了 BIOS 段的较低地址处。

## Exercise 2

使用 GDB 的 si(Step Instruction) 指令，来跟踪查看 ROM BIOS 中的更多指令，并试着说明其作用。

```
The target architecture is assumed to be i8086
[f000:fff0]    0xffff0:	ljmp   $0xf000,$0xe05b
[f000:e05b]    0xfe05b:	cmpl   $0x0,%cs:0x6ac8
[f000:e062]    0xfe062:	jne    0xfd2e1
[f000:e066]    0xfe066:	xor    %dx,%dx
[f000:e068]    0xfe068:	mov    %dx,%ss
[f000:e06a]    0xfe06a:	mov    $0x7000,%esp
[f000:e070]    0xfe070:	mov    $0xf34c2,%edx
[f000:e076]    0xfe076:	jmp    0xfd15c
[f000:d15c]    0xfd15c:	mov    %eax,%ecx
[f000:d15f]    0xfd15f:	cli
[f000:d160]    0xfd160:	cld
[f000:d161]    0xfd161:	mov    $0x8f,%eax
[f000:d167]    0xfd167:	out    %al,$0x70
[f000:d169]    0xfd169:	in     $0x71,%al
[f000:d16b]    0xfd16b:	in     $0x92,%al
[f000:d16d]    0xfd16d:	or     $0x2,%al
[f000:d16f]    0xfd16f:	out    %al,$0x92
[f000:d171]    0xfd171:	lidtw  %cs:0x6ab8
[f000:d177]    0xfd177:	lgdtw  %cs:0x6a74
[f000:d17d]    0xfd17d:	mov    %cr0,%eax
[f000:d180]    0xfd180:	or     $0x1,%eax
[f000:d184]    0xfd184:	mov    %eax,%cr0
[f000:d187]    0xfd187:	ljmpl  $0x8,$0xfd18f
The target architecture is assumed to be i386
=> 0xfd18f:	mov    $0x10,%eax
=> 0xfd194:	mov    %eax,%ds
=> 0xfd196:	mov    %eax,%es
=> 0xfd198:	mov    %eax,%ss
=> 0xfd19a:	mov    %eax,%fs
=> 0xfd19c:	mov    %eax,%gs
...
```

当 BIOS 启动后，它会设置 Interrupt Descriptor Table(中断描述符表)，然后初始化各种设备，例如 VGA(Video Graphics Array)。

在初始化完 PCI(Peripheral Component Interconnect) 总线后，BIOS 会找到可引导盘，读取可引导盘中的 Boot Loader，然后将控制权转交给 Boot Loader。

# Part 2: The Boot Loader

软盘和硬盘被分成一个个扇区(sector)，一个扇区大小为 512B，扇区是磁盘的最小单位，每次读写的大小必须大于等于一个扇区，如果该盘是可引导盘，那么第一个扇区被称为引导扇区(boot sector)，引导扇区中装有 Boot Loader 的代码。

当 BIOS 完成系统初始化后，就会去寻找可引导盘，将可引导盘的第一个扇区(512B)的内容加载到物理内存地址为 0x7c00 ~ 0x7dff 之间恰好 512B 的区域，然后使用一个 jmp 指令，将 CS:IP 设置为 0000:7c00，并将控制权交给 Boot Loader。

到后来 Boot Loader 已经可以通过 CD-ROM 加载，这种实现比较复杂，但是也更有效。例如，CD-ROM 中扇区大小增加到了 2048B，并且一次也能加载进多个扇区。

对于 6.828 我们使用的是传统的方法，即 Boot Loader 装在一个 512B 大小的扇区里。Boot Loader 包含了一个汇编语言源文件 boot/boot.S 和一个 C 语言源文件 boot/main.c，首先确保理解这两个文件的内容。

这个 Boot loader 负责启动磁盘中的 kernel image。boot.S 和 main.c 合称为 bootloader，这两个文件应该存储在磁盘的第一个扇区，从第二个扇区开始，存放 kernel image，kernel image 必须是 ELF 格式的。

当 CPU 启动后，它将 BIOS 加载进内存执行，BIOS 初始化一些设备，然后将装有 Boot Loader 的扇区加载进内存，并 jump 到它，开始执行 boot.S，在 boot.S 中完成实模式到保护模式到切换，然后调 bootmain()，最后完成加载磁盘中的 kernel image 的任务。

boot.S:

```
#include <inc/mmu.h>

# Start the CPU: switch to 32-bit protected mode, jump into C.
# The BIOS loads this code from the first sector of the hard disk into
# memory at physical address 0x7c00 and starts executing in real mode
# with %cs=0 %ip=7c00.

.set PROT_MODE_CSEG, 0x8         # kernel code segment selector
.set PROT_MODE_DSEG, 0x10        # kernel data segment selector
.set CR0_PE_ON,      0x1         # protected mode enable flag

.globl start
start:
  .code16                     # Assemble for 16-bit mode
  cli                         # Disable interrupts 关闭中断
  cld                         # String operations increment 将 DF 置零

  # Set up the important data segment registers (DS, ES, SS). 将这三个段寄存器置零
  xorw    %ax,%ax             # Segment number zero
  movw    %ax,%ds             # -> Data Segment
  movw    %ax,%es             # -> Extra Segment
  movw    %ax,%ss             # -> Stack Segment

  # Enable A20:
  #   For backwards compatibility with the earliest PCs, physical
  #   address line 20 is tied low, so that addresses higher than
  #   1MB wrap around to zero by default.  This code undoes this.
  #   即下面的代码将会解除地址环绕现象，以获得更多的寻址能力
seta20.1:
  inb     $0x64,%al               # Wait for not busy 将 0x64 端口的内容拷贝进 %al
  testb   $0x2,%al                # 
  jnz     seta20.1                # 只要 %al 中不等于 0x2，就继续循环

  movb    $0xd1,%al               # 0xd1 -> port 0x64 此时 %al 中等于 0x2
  outb    %al,$0x64               # 将 0xd1 写入 0x64 端口

seta20.2:
  inb     $0x64,%al               # Wait for not busy
  testb   $0x2,%al
  jnz     seta20.2

  movb    $0xdf,%al               # 0xdf -> port 0x60
  outb    %al,$0x60               # 将 0xdf 写入 0x60 端口，打开 A20

  # Switch from real to protected mode, using a bootstrap GDT
  # and segment translation that makes virtual addresses 
  # identical to their physical addresses, so that the 
  # effective memory map does not change during the switch.
  lgdt    gdtdesc                 # 从内存中加载 GDTR 值
  movl    %cr0, %eax              # cr0 寄存器，如果为 1，系统处于保护模式，否则处于实模式
  orl     $CR0_PE_ON, %eax
  movl    %eax, %cr0              # 这四条指令，将 cr0 置 1，启动保护模式，并设置了 GDT

  # Jump to next instruction, but in 32-bit code segment.
  # Switches processor into 32-bit mode.
  ljmp    $PROT_MODE_CSEG, $protcseg

  .code32                     # Assemble for 32-bit mode
protcseg:
  # Set up the protected-mode data segment registers 将各个段寄存器的值设置为 0x10
  movw    $PROT_MODE_DSEG, %ax    # Our data segment selector
  movw    %ax, %ds                # -> DS: Data Segment
  movw    %ax, %es                # -> ES: Extra Segment
  movw    %ax, %fs                # -> FS
  movw    %ax, %gs                # -> GS
  movw    %ax, %ss                # -> SS: Stack Segment

  # Set up the stack pointer and call into C.
  movl    $start, %esp            # 将 start 处设置为栈指针，是因为栈向低地址生长，而程序代码则相反
  call bootmain                   # 下面进入 bootmain

  # If bootmain returns (it shouldn't), loop.
spin:
  jmp spin

# Bootstrap GDT
.p2align 2                                # force 4 byte alignment
gdt:
  SEG_NULL                              # null seg
  SEG(STA_X|STA_R, 0x0, 0xffffffff)     # code seg
  SEG(STA_W, 0x0, 0xffffffff)           # data seg

gdtdesc:
  .word   0x17                            # sizeof(gdt) - 1
  .long   gdt                             # address gdt
```

为了理解 main.c 的内容，需要 ELF 的预备知识，下面是 kernel 的 file header 和 program header:

![kernel file header](http://ww1.sinaimg.cn/large/c9caade4gy1g2a5igwqb3j217s0v07pg.jpg)
![kernel program header](http://ww1.sinaimg.cn/large/c9caade4gy1g2a7ff33rgj21cs0ligzs.jpg)

From the program header table, we see that three memory segments will be initialized with the contents of the executable object file. 

代码中的注释结合图片内容更容易理解。

```c
#include <inc/x86.h>
#include <inc/elf.h>

#define SECTSIZE	512
#define ELFHDR		((struct Elf *) 0x10000) // scratch space

void readsect(void*, uint32_t);
void readseg(uint32_t, uint32_t, uint32_t);

void
bootmain(void)
{
	// 这个结构体是 Program Header 的缩写，在 elf.h 中
	// 这个结构体描述了可执行文件段与内存段之间的映射关系 - 见 Program Header Table
	struct Proghdr *ph, *eph;

	// read 1st page off disk
	// 从 file(kernel) 的第 0 个字节开始，拷贝 512 * 8 字节(即 8 个扇区到大小)到内存物理地址 0x10000 起始处
	readseg((uint32_t) ELFHDR, SECTSIZE*8, 0);

	// is this a valid ELF?
	if (ELFHDR->e_magic != ELF_MAGIC)
		goto bad;

	// load each program segment (ignores ph flags)
	// 加载每一个 segment
	// Excutable Object File 是由多个 segment 组成的，把这些 segment 加载完了
	// 也就意味这 kernel image 加载完成
	// 计算 program header 的地址
	ph = (struct Proghdr *) ((uint8_t *) ELFHDR + ELFHDR->e_phoff);
	// program header 结束的地址
	eph = ph + ELFHDR->e_phnum;
	// 从 file header 看来，Number of program header = 3，所以这里循环 3 次
	// 
	for (; ph < eph; ph++)
		// p_pa is the load address of this segment (as well
		// as the physical address)
		// 将 file(kernel) 中相应的连续的 section 拷贝进内存相应位置
		readseg(ph->p_pa, ph->p_memsz, ph->p_offset);

	// call the entry point from the ELF header
	// the address of the first instruction to execute when the program runs - 见 program entry point
	// note: does not return!
	((void (*)(void)) (ELFHDR->e_entry))();

bad:
	outw(0x8A00, 0x8A00);
	outw(0x8A00, 0x8E00);
	while (1)
		/* do nothing */;
}

// Read 'count' bytes at 'offset' from kernel into physical address 'pa'.
// Might copy more than asked
// 这个函数显然要读取磁盘
void
readseg(uint32_t pa, uint32_t count, uint32_t offset)
{
	uint32_t end_pa;
    // 物理内存中一个 segment 的结束地址
	end_pa = pa + count;

	// round down to sector boundary
	// 将 pa 向下舍入到扇区边界
	pa &= ~(SECTSIZE - 1);

	// translate from bytes to sectors, and kernel starts at sector 1
	// 找到 offset 所在的扇区，因为 kernel 从第二个扇区开始，所以要 +1
	offset = (offset / SECTSIZE) + 1;

	// If this is too slow, we could read lots of sectors at a time.
	// We'd write more to memory than asked, but it doesn't matter --
	// we load in increasing order.
	while (pa < end_pa) {
		// Since we haven't enabled paging yet and we're using
		// an identity segment mapping (see boot.S), we can
		// use physical addresses directly.  This won't be the
		// case once JOS enables the MMU.
		// 因为这时候还没有启动使用分页，所以可以直接使用物理内存，使用分页后，
		// 就不能直接操作物理内存了，而是通过虚拟内存映射到物理内存，所以分页后，
		// 只能操作虚拟内存
		readsect((uint8_t*) pa, offset); //
		pa += SECTSIZE;
		offset++;
	}
}

void
waitdisk(void)
{
	// wait for disk reaady
	while ((inb(0x1F7) & 0xC0) != 0x40)
		/* do nothing */;
}

// 根据 program header 的指示，将 file(kernel) 中的 section 加载到 segment 中，
// section 是存在于 file 中，而 file 又存在于磁盘上，所以要读取磁盘上的扇区。
void
readsect(void *dst, uint32_t offset)
{
	// wait for disk to be ready
	waitdisk();
    // http://www.philipstorr.id.au/pcbook/book2/ioassign.htm
	// 
	outb(0x1F2, 1);		// count = 1
	outb(0x1F3, offset);
	outb(0x1F4, offset >> 8);
	outb(0x1F5, offset >> 16);
	outb(0x1F6, (offset >> 24) | 0xE0);
	outb(0x1F7, 0x20);	// cmd 0x20 - read sectors

	// wait for disk to be ready
	waitdisk();

	// read a sector
	insl(0x1F0, dst, SECTSIZE/4);
}

```

Boot Loader 必须完成下面两个功能:

1. Boot Loader 将处理器从实模式切换到 32-bit 的保护模式，因为只有在保护模式下，才能寻址到 0x00100000 地址之上的物理地址空间(从 program header 中可以看到，segment 的地址都是在 0x00100000 之上)。在 32-bit 保护模式下，将 (Segment:offset) 转换为物理地址使用了完全不同的方法，例如，offset 从 16bit 增到了 32bit。参考[PC Assembly Language](https://pdos.csail.mit.edu/6.828/2018/readings/pcasm-book.pdf) sections 1.2.7 和 1.2.8。
2. Boot Loader 通过专用的 I/O 指令来直接获取 IDE 磁盘设备寄存器，来达到从硬盘中读取 kernel 的目的。

理解了 boot.S 和 main.c 后，可以看一下 obj/boot/boot.asm，这个文件是 boot.S 和 main.c 的反汇编版本，通过这个文件可以很清楚到看到 Boot Loader 处于物理内存的哪个地方。同样，obj/kern/kernel.asm 也包括了 JOS kernel 的反汇编。

## Exercise 3

1. 设置一个断点在 Boot 扇区加载的地方 0x7c00，跳到断点处，接着单步执行，利用 boot/boot.S 和 boot.asm 来判断当前执行到了什么地方。使用 x/i 命令，比较 boot loader 源文件、boot.asm 和 GDB 时的反汇编，看看这三者有什么区别。
2. 进入到 readsect()，确认汇编指令与 C 代码之间的对应关系。
3. 返回到 bootmain()，确定 for 循环读取了剩下所有的扇区。当 for 循环完成后，将会执行什么代码，在那里设置好断点，单步执行完剩余的 boot loader。

并回答下面的问题:

> At what point does the processor start executing 32-bit code? What exactly causes the switch from 16- to 32-bit mode?

从 boot.S 中可以看出，执行 movl  %eax, %cr0 后，%cr0 被置 0，此时 CPU 从 16-bit 切换到 32-bit，即从实模式切换到了保护模式。

> What is the last instruction of the boot loader executed, and what is the first instruction of the kernel it just loaded? Where is the first instruction of the kernel?

第一个问题名，通过查看 boot.asm 得知 boot loader 最后一条指令为 
`7d6b: ff 15 18 00 01 00   call   *0x10018` 对应 main.c 中的 `((void (*)(void)) (ELFHDR->e_entry))();`

后面两个问题，通过查看 obj/kern/kernel.asm，截取文件开头几行:
![1](http://ww1.sinaimg.cn/large/c9caade4gy1g2abd1fhpqj21cs0y6h6f.jpg)
可以看出，里面有两个 entry，那么到底哪一个才是 kernel 的入口呢？最好的办法就是通过 gdb 调试，将断点打在 0x7d6b，也即是 boot loader 的最后一条指令处，再执行一步，如下:
![2](http://ww1.sinaimg.cn/large/c9caade4gy1g2abo5rj9jj21cs0y6e56.jpg)
可知，kernel 中执行的第一条指令是 `0x10000c: movw   $0x1234,0x472`，那么加载的第一条指令自然就是 `movw $0x1234,0x472 #warm boot`。

> How does the boot loader decide how many sectors it must read in order to fetch the entire kernel from disk? Where does it find this information?

