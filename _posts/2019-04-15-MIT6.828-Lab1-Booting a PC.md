---
layout: post
title: "MIT6.828 操作系统 Lab1:Booting a PC"
comments: true
description: "MIT6.828 操作系统 Lab1:Booting a PC"
keywords: "Lab, 6.828, MIT"
---

# 介绍

这个实验分为 3 部分，第一部分用来熟悉 x86 汇编，QEMU 和 PC 启动过程。第二部分实操 6.828 kernel 的启动加载。第三部分，探索 6.828 kernel 的初始化。

## 软件设置

实验使用 git 版本控制系统，仓库地址为 [](https://pdos.csail.mit.edu/6.828/2018/jos.git)，使用命令将仓库 clone 到本地。

在实验开始之前需要安装 `qemu` 和 `gcc`，参考链接为[tool page](https://pdos.csail.mit.edu/6.828/2018/tools.html)。

# Part 1: PC Bootstrap

这个作业的目的是介绍 x86 汇编语言和 PC 启动过程，并熟悉 QEMU 和 QEMU/GDB 调试。

## Getting Started with x86 assembly

下面是实验中提供的一些关于汇编的资源：

1. [PC Assembly Language](https://pdos.csail.mit.edu/6.828/2018/readings/pcasm-book.pdf)
2. [Brennan's Guide to Inline Assembly](http://www.delorie.com/djgpp/doc/brennan/brennan_att_inline_djgpp.html)
3. [Intel® 64 and IA-32 Architectures Software Developer Manuals
](https://software.intel.com/en-us/articles/intel-sdm)

这三份资源，第一个是对汇编语言的入门教材，由于这个课程是用的是 GUN assembler，而不是 NASM assenbler，所以提供了第二份资料来学习 Intel 与 AT&T 汇编语法的差别。

第三份资料则是最权威的 Intel 开发手册。

## Simulating the x86

qemu 内置的 debug 功能受限，我们将换用 gdb 进行调试。

编译上面 clone 下来的仓库代码，注意前提是安装好了实验指定版本的 qemu 和 gcc。

编译完 JOS kernel 后，执行 `make qemu`，最终 qemu 窗口显示如下文本:

```c
Booting from Hard Disk...
6828 decimal is XXX octal!
entering test_backtrace 5
entering test_backtrace 4
entering test_backtrace 3
entering test_backtrace 2
entering test_backtrace 1
entering test_backtrace 0
leaving test_backtrace 0
leaving test_backtrace 1
leaving test_backtrace 2
leaving test_backtrace 3
leaving test_backtrace 4
leaving test_backtrace 5
Welcome to the JOS kernel monitor!
Type 'help' for a list of commands.
K>
```

**Booting from Hard Disk...** 后所有的输出都来自于 JOS 内核。

JOS 内核目前只有两条命令 **help** 和 **kerninfo**。

## The PC's Physical Address Space

PC 的物理地址布局通常如下:

```
+------------------+  <- 0xFFFFFFFF (4GB)
|      32-bit      |
|  memory mapped   |
|     devices      |
|                  |
/\/\/\/\/\/\/\/\/\/\

/\/\/\/\/\/\/\/\/\/\
|                  |
|      Unused      |
|                  |
+------------------+  <- depends on amount of RAM
|                  |
|                  |
| Extended Memory  |
|                  |
|                  |
+------------------+  <- 0x00100000 (1MB)
|     BIOS ROM     |
+------------------+  <- 0x000F0000 (960KB)
|  16-bit devices, |
|  expansion ROMs  |
+------------------+  <- 0x000C0000 (768KB)
|   VGA Display    |
+------------------+  <- 0x000A0000 (640KB)
|                  |
|    Low Memory    |
|                  |
+------------------+  <- 0x00000000
```

世界上第一台 PC，是基于 16 位都 Intel 8088 处理器，但是那时的地址线有 20 bit，所以能寻址到 2^20 byte(1MB)，所以早期 PC 的内存地址范围为 0x00000000 ~ 0x000FFFFF(1MB)，图中的 Low Memory 是早期 PC 能够使用的 RAM 范围。

从 0x000A0000 到 0x000FFFFF (1024KB - 640KB = 384KB)这个范围，主要是为了硬件保留的，其中最重要的是 BIOS ROM 这块区域，早期 PC 的 BIOS 是 ROM，现代的 PC 已经将其换成可更新的 Flash Memory 了。

BIOS 主要负责系统初始化，例如激活 Video Card 和检查内存容量等。完成初始化后，BIOS 将操作系统从软盘、硬盘、CD 或者网络加载进来，然后将控制权转交给操作系统。

虽然后来的 80286 和 80386 处理器分别已经将寻址范围扩大到 16MB 和 4GB，为了保持软件向后兼容，PC 架构仍然保留了上图中 0x00000000 ~ 0x00100000 中的布局结构。因为这些历史原因，RAM 被分割成了两部分:

1. low/conventional memory(0x00000000 ~ 0x000A0000 640KB)
2. extended memory(0x00100000 ~ )

这两部分被 0x000A0000 ~ 0x00100000 这块区域分割开来，我们将这块区域叫做 “hole”。另外，在 32 位 PC 架构的机器上，高地址处通常为 PCI 设备保留着。

最近的一些 x86 处理器已经能够支持超过 4GB 的 RAM 了。这种情况下，BIOS 应该预留第二个 “hole”，它位于高地址区域。因为 JOS 的设计受限，只会使用到上图中前 256MB 的物理内存空间，所以从现在开始，假设 PC 只有 4GB 的物理内存空间。

## The ROM BIOS

在这部分，将会学习使用 QEMU 的 debug 功能来探索 IA-32 兼容计算机的启动过程。

首先启动两个 shell，都进入 lab 目录，其中一个执行 `make qemu-nox-gdb`，另一个执行 `make gdb` 后，显示如下:

```
wu@wu-insparition-5421:~/6.828/lab$ make gdb
gdb -n -x .gdbinit
GNU gdb (Ubuntu 8.1-0ubuntu3) 8.1.0.20180409-git
Copyright (C) 2018 Free Software Foundation, Inc.
License GPLv3+: GNU GPL version 3 or later <http://gnu.org/licenses/gpl.html>
This is free software: you are free to change and redistribute it.
There is NO WARRANTY, to the extent permitted by law.  Type "show copying"
and "show warranty" for details.
This GDB was configured as "x86_64-linux-gnu".
Type "show configuration" for configuration details.
For bug reporting instructions, please see:
<http://www.gnu.org/software/gdb/bugs/>.
Find the GDB manual and other documentation resources online at:
<http://www.gnu.org/software/gdb/documentation/>.
For help, type "help".
Type "apropos word" to search for commands related to "word".
+ target remote localhost:26000
warning: No executable has been specified and target does not support
determining executable automatically.  Try using the "file" command.
warning: A handler for the OS ABI "GNU/Linux" is not built into this configuration
of GDB.  Attempting to continue with the default i8086 settings.

The target architecture is assumed to be i8086
[f000:fff0]    0xffff0:	ljmp   $0xf000,$0xe05b
0x0000fff0 in ?? ()
+ symbol-file obj/kern/kernel
(gdb) 
```

下面这行:

```
[f000:fff0]    0xffff0:	ljmp   $0xf000,$0xe05b
```

是 GDB 对第一条指令的反汇编，从中我们有如下推断:

1. IBM PC 从物理地址 0x000ffff0(稍后会介绍这个地址的计算方法) 处开始执行，这个位置位于 ROM BIOS 里面
2. PC 开始执行时，CS = 0xf000，IP = 0xfff0
3. 第一条指令是 jmp 指令，它跳转到 CS = 0xf000 IP = 0xe05b 处

这种做法源自于 Intel 对 8088 处理器的设计，因为 BIOS 永远都在 0x000f0000 ~ 0x000fffff 这个范围内，这就保证了只要 PC 一接通电源，BIOS 能第一时间控制到 PC，这是很关键的，因为在接通电源的瞬间，RAM 中除了 BIOS 没有其他的软件能够执行。

如上面所说，PC 在接通电源后，处理器进入 Real Mode(实模式)，将 CS 和 IP 分别设置成 0xf000 和 0xfff0。由于 PC 刚启动后，处理器处于 Real Mode(实模式)，在实模式下，地址转换使用下面的公式:

> Physical Address = 16 * Segment(CS) + offset(IP)

所以，第一条指令的地址计算为: 0xf000 * 16 + 0xfff0 = 0x000ffff0。

然而 0x000ffff0 距离 BIOS 的范围结束(0x00100000)只有 16bytes，由于 16bytes 所做的事情有限，所以第一条 jmp 指令跳到了 BIOS 段的较低地址处。

## Exercise 2

使用 GDB 的 si(Step Instruction) 指令，来跟踪查看 ROM BIOS 中的更多指令，并试着说明其作用。

```
The target architecture is assumed to be i8086
[f000:fff0]    0xffff0:	ljmp   $0xf000,$0xe05b
[f000:e05b]    0xfe05b:	cmpl   $0x0,%cs:0x6ac8
[f000:e062]    0xfe062:	jne    0xfd2e1
[f000:e066]    0xfe066:	xor    %dx,%dx
[f000:e068]    0xfe068:	mov    %dx,%ss
[f000:e06a]    0xfe06a:	mov    $0x7000,%esp
[f000:e070]    0xfe070:	mov    $0xf34c2,%edx
[f000:e076]    0xfe076:	jmp    0xfd15c
[f000:d15c]    0xfd15c:	mov    %eax,%ecx
[f000:d15f]    0xfd15f:	cli
[f000:d160]    0xfd160:	cld
[f000:d161]    0xfd161:	mov    $0x8f,%eax
[f000:d167]    0xfd167:	out    %al,$0x70
[f000:d169]    0xfd169:	in     $0x71,%al
[f000:d16b]    0xfd16b:	in     $0x92,%al
[f000:d16d]    0xfd16d:	or     $0x2,%al
[f000:d16f]    0xfd16f:	out    %al,$0x92
[f000:d171]    0xfd171:	lidtw  %cs:0x6ab8
[f000:d177]    0xfd177:	lgdtw  %cs:0x6a74
[f000:d17d]    0xfd17d:	mov    %cr0,%eax
[f000:d180]    0xfd180:	or     $0x1,%eax
[f000:d184]    0xfd184:	mov    %eax,%cr0
[f000:d187]    0xfd187:	ljmpl  $0x8,$0xfd18f
The target architecture is assumed to be i386
=> 0xfd18f:	mov    $0x10,%eax
=> 0xfd194:	mov    %eax,%ds
=> 0xfd196:	mov    %eax,%es
=> 0xfd198:	mov    %eax,%ss
=> 0xfd19a:	mov    %eax,%fs
=> 0xfd19c:	mov    %eax,%gs
...
```

当 BIOS 启动后，它会设置 Interrupt Descriptor Table(中断描述符表)，然后初始化各种设备，例如 VGA(Video Graphics Array)。

在初始化完 PCI(Peripheral Component Interconnect) 总线后，BIOS 会找到可引导盘，读取可引导盘中的 Boot Loader，然后将控制权转交给 Boot Loader。

# Part 2: The Boot Loader

软盘和硬盘被分成一个个扇区(sector)，一个扇区大小为 512B，扇区是磁盘的最小单位，每次读写的大小必须大于等于一个扇区，如果该盘是可引导盘，那么第一个扇区被称为引导扇区(boot sector)，引导扇区中装有 Boot Loader 的代码。

当 BIOS 完成系统初始化后，就会去寻找可引导盘，将可引导盘的第一个扇区(512B)的内容加载到物理内存地址为 0x7c00 ~ 0x7dff 之间恰好 512B 的区域，然后使用一个 jmp 指令，将 CS:IP 设置为 0000:7c00，并将控制权交给 Boot Loader。

到后来 Boot Loader 已经可以通过 CD-ROM 加载，这种实现比较复杂，但是也更有效。例如，CD-ROM 中扇区大小增加到了 2048B，并且一次也能加载进多个扇区。

对于 6.828 我们使用的是传统的方法，即 Boot Loader 装在一个 512B 大小的扇区里。Boot Loader 包含了一个汇编语言源文件 boot/boot.S 和一个 C 语言源文件 boot/main.c，首先确保理解这两个文件的内容。

Boot Loader 必须完成下面两个功能:

1. Boot Loader 将处理器从实模式切换到 32-bit 的保护模式，因为只有在保护模式下，才能寻址到 0x00100000 地址之上的物理地址空间。在 32-bit 保护模式下，将 (Segment:offset) 转换为物理地址使用了完全不同的方法，例如，offset 从 16bit 增到了 32bit。参考[PC Assembly Language](https://pdos.csail.mit.edu/6.828/2018/readings/pcasm-book.pdf) sections 1.2.7 和 1.2.8。
2. Boot Loader 通过专用的 I/O 指令来直接获取 IDE 磁盘设备寄存器，来达到从硬盘中读取 kernel 的目的。