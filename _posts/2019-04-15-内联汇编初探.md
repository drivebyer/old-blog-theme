---
layout: post
title: "内联汇编初探"
comments: true
description: "内联汇编初探"
keywords: "inline, assembly, 内联, 汇编"
---

## The Syntax

___

### The difference between AT&T and Intel

___

#### 寄存器名

___

```
AT&T: %eax
Intel: eax
```

#### 源/目的寄存器顺序

___

将 eax 里的值放进 ebx：

```
AT&T: movl %eax, %ebx
Intel: mov ebx, eax
```

#### 常量/立即数格式

___

将 c 中的静态变量 **booga** 的地址放进 eax 寄存器：

```
AT&T: movl $_booga, %eax
Intel: mov eax, _booga
```

将常数 **0xD00D** 放进 ebx 寄存器：

```
AT&T: movl $0xD00D, %ebx
Intel: mov ebx, D00Dh
```

#### 引用内存

___

如下两种格式：

```
AT&T: immed32[basepointer, indexpointer, indexscale]
Intel: [basepointer + indexpointer*indexscale + immed32]
```

这四个域中，只有 **immed32** 和 **basepointer** 是必须存在的，下面是常用的一些格式：

```
Addressing a particular C variable:
AT&T: _booga
Intel: [_booga]
(“_” 下划线只能对全局变量使用)
```

```
Addressing what a register points to:
AT&T: (%eax)
Intel: [%eax]
```

```
Addressing a variable offset by a value in a register:
AT&T: _variable(%eax)
Intel: [eax + _variable]
```

```
Addressing a value in an array of integers (scaling up by 4):
AT&T:  _array(,%eax,4)
Intel: [eax*4 + array]
```

```
You can also do offsets with the immediate value:
C code: *(p+1) where p is a char *
AT&T:  1(%eax) where eax has the value of p
Intel: [eax + 1]
```

```
Addressing a particular char in an array of 8-character records:
eax holds the number of the record desired. ebx has the wanted char's offset within the record.
AT&T:  _array(%ebx,%eax,8)
Intel: [ebx + eax*8 + _array]
```

注意：在寻址的时候，如果要用到 %esp 寄存器，只能将其当作 basepointer。
 
## Basic inline assembly

___

最基本的内联汇编格式如下:

```c
asm ("statements");
```

例如，asm ("cli") 将会禁止中断发生，asm ("sti") 执行后又恢复中断。如果 asm 与程序内容冲突，也可以使用 _asm_ 代替。

将一个 asm 中有多个 statements 也是可以的，像下面这样:

```c
asm ("pushl %eax\n\t"
     "movl $0, %eax\n\t"
     "popl %eax");
```

It's really meant for issuing instructions for which there is no equivalent in C and don't touch the registers.

## Extended inline assembly

___

还有一种允许输入输出参数的格式，如下:

```c
asm ( "statements" : output_registers : input_registers : clobbered_registers);
```

来看下面的例子:

```c
asm ("cld\n\t"
     "rep\n\t"
     "stosl"
     : /* no output registers */
     : "c" (count), "a" (fill_value), "D" (dest)
     : "%ecx", "%edi" );
```

上面的指令将 fill_vlaue * count 放进 dest 地址所在的地方。