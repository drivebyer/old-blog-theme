---
layout: post
title: "内联汇编初探"
comments: true
description: "内联汇编初探"
keywords: "inline, assembly, 内联, 汇编"
---

## Why inline assembly

___

(内联汇编)[https://zh.wikipedia.org/wiki/%E5%86%85%E8%81%94%E6%B1%87%E7%BC%96] 是 GCC 对 C 语言的扩充，可以直接在 C 语言语句中插入汇编代码。当我们需要执行一个指令，而这个指令不能通过 C 语言来完成的时候，就需要向 C 语言中插入内联汇编。例如 (lgdt/lidt)[https://pdos.csail.mit.edu/6.828/2005/readings/i386/LGDT.htm] 指令，C 语言中没有对应的表述，这时候就只能使用内联汇编。

## The Syntax

___

### The difference between AT&T and Intel

___

#### 寄存器名

___

```
AT&T: %eax
Intel: eax
```

#### 源/目的寄存器顺序

___

将 eax 里的值放进 ebx：

```
AT&T: movl %eax, %ebx
Intel: mov ebx, eax
```

#### 常量/立即数格式

___

将 c 中的静态变量 **booga** 的地址放进 eax 寄存器：

```
AT&T: movl $_booga, %eax
Intel: mov eax, _booga
```

将常数 **0xD00D** 放进 ebx 寄存器：

```
AT&T: movl $0xD00D, %ebx
Intel: mov ebx, D00Dh
```

#### 引用内存

___

如下两种格式：

```
AT&T: immed32[basepointer, indexpointer, indexscale]
Intel: [basepointer + indexpointer*indexscale + immed32]
```

这四个域中，只有 **immed32** 和 **basepointer** 是必须存在的，下面是常用的一些格式：

```
Addressing a particular C variable:
AT&T: _booga
Intel: [_booga]
(“_” 下划线只能对全局变量使用)
```

```
Addressing what a register points to:
AT&T: (%eax)
Intel: [%eax]
```

```
Addressing a variable offset by a value in a register:
AT&T: _variable(%eax)
Intel: [eax + _variable]
```

```
Addressing a value in an array of integers (scaling up by 4):
AT&T:  _array(,%eax,4)
Intel: [eax*4 + array]
```

```
You can also do offsets with the immediate value:
C code: *(p+1) where p is a char *
AT&T:  1(%eax) where eax has the value of p
Intel: [eax + 1]
```

```
Addressing a particular char in an array of 8-character records:
eax holds the number of the record desired. ebx has the wanted char's offset within the record.
AT&T:  _array(%ebx,%eax,8)
Intel: [ebx + eax*8 + _array]
```

注意：在寻址的时候，如果要用到 %esp 寄存器，只能将其当作 basepointer。
 
## Basic inline assembly

___

最基本的内联汇编格式如下:

```
asm ("statements");
```

例如，asm ("cli") 将会禁止中断发生，asm ("sti") 执行后又恢复中断。如果 asm 与程序内容冲突，也可以使用 _asm_ 代替。

一个 asm 中有多个 statements 也是可以的，像下面这样:

```
asm ("pushl %eax\n\t"
     "movl $0, %eax\n\t"
     "popl %eax");
```

在某些功能不能用 C 语言完成且不会修改寄存器值的情况下，这种方法是适用的。

可一旦使用这种汇编格式，修改了寄存器的值：

```
asm ("movl %eax, %ebx"); # 修改了寄存器 %ebx 的值
asm ("xorl %ebx, %edx"); # 修改了寄存器 %edx 的值
asm ("movl $0, _booga"); # 修改了 booga 变量的值
```

一旦这样使用，将会给程序带来巨大的破坏，这是因为你没有告诉 GCC，你对哪些地方做了修改，而那些 old value，有可能其正好是 GCC 在后面会用到的，为了解决这个问题，请看下面：

## Extended inline assembly

___

格式如下:

```
asm ( "statements": 
       output_registers :     # 可选 
       input_registers :      # 可选
       clobbered_registers);  # 可选
```

来看下面的例子:

```
asm ("cld\n\t"
     "rep\n\t"
     "stosl"
     : /*no output registers*/
     : "c" (count), "a" (fill_value), "D" (dest)
     : "%ecx", "%edi" );
```

上面的指令将 fill_vlaue * count 放进 dest 地址所在的地方。

```
asm ("cld\n\t"   # clear the direction bit of the flags register
```

```
"rep\n\t"   # occupy a line
"stosl"     # copy the data from %al/%ax/%eax to destination string, pointed to by ES:DI in memory
```

```
 : "c" (count), "a" (fill_value), "D" (dest)
```

在这句话里，我们将 count 加载进 %ecx，将 fill_value 加载进 %eax，将 dest 加载进 %edi。

```
: "%ecx", "%edi" );
```

通过这句话，我们告诉 GCC：you can no longer count on the values you loaded into ecx or edi to be valid.

这样在优化的时候，GCC 就知道这些寄存器有些什么变化。

下面是你可能会使用到的一些寄存器：

a        eax
b        ebx
c        ecx
d        edx
S        esi
D        edi
I        constant value (0 to 31)
q,r      dynamically allocated register (see below)
g        eax, ebx, ecx, edx or variable in memory
A        eax and edx combined into a 64-bit integer (use long longs)

代码必须使用双引号，表达式必须使用圆括号。

### Example 1

```
asm ("leal (%1,%1,4), %0"
     : "=r" (x)
     : "0" (x) );
```

这条语句计算了 (x * 5)，并且仅仅使用了一个 cycle。

### Example 2

内联汇编代码：

```
uint32_t cr0;
asm volatile("movl %%cr0, %0\n": "=r"(cr0)); # 将 %cr0 的内容 copy 到 %0 这个寄存器里，这个寄存器的内容最终会赋值给 cr0 变量。
cr0 |= 0x80000000; # 将 cr0 变量最高位置1
asm volatile("movl %0, %%cr0\n": :"r"(cr0)); # 将 cr0 变量的值写回到 %cr0 寄存器
```

相应的汇编代码：

```
movl %cr0, %ebx
movl %ebx, 12(%esp)       # 12(%esp) 为上面的栈帧的局部变量 cr0
orl $-2147483648, 12(%esp)
movl 12(%esp), %eax
movl %eax, %cr0
```

- volatile: No recording; No elimination
- %0: The first constraint following
- r: A constraint; GCC is free to use any register

在上面的例子中，前半部分 r 使用了 %ebx 来传递，而后半部分则使用了 %eax。

参考资料：

1. (Inline assembly for x86 in Linux)[https://www.ibm.com/developerworks/library/l-ia/index.html]
2. (How to Use Inline Assembly Language in C Code)[https://gcc.gnu.org/onlinedocs/gcc-7.4.0/gcc/Using-Assembly-Language-with-C.html#Using-Assembly-Language-with-C]
3. (Brennan's Guide to Inline Assembly)[http://www.delorie.com/djgpp/doc/brennan/brennan_att_inline_djgpp.html]