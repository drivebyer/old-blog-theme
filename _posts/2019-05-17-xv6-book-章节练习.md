---
layout: post
title: "xv6 book 章节练习"
comments: true
description: "xv6 book 章节练习"
keywords: "xv6, book"
---

非标准答案，仅供参考。

## Chapter 1

> Set a breakpoint at swtch. Single step with gdb’s stepi through the ret to forkret, then use gdb’s finish to proceed to trapret, then stepi until you get to initcode at virtual address zero.

> KERNBASE limits the amount of memory a single process can use, which might be irritating on a machine with a full 4 GB of RAM. Would raising KERNBASE allow a process to use more memory?

## Chapter 2

> Look at real operating systems to see how they size memory.

> If xv6 had not used super pages, what would be the right declaration for entrypgdir?

kernel 通过设置 %cr4 来启动处理器的 PSE 功能，启动后，虚拟地址的第 7 位被激活，利用该位来表示 PDE 是一个 page table 还是直接指向一个 super page，启动 PSE 前后的地址转换对比图:

![PSE](http://ww1.sinaimg.cn/large/c9caade4gy1g34hcb22daj22e81g01he.jpg)

所以如果不使用 super page，那么 entrypgdir 的声明应该变成这样:

```
pde_t entrypgdir[NPDENTRIES] = {
    [0] = (0) | PTE_P | PTE_W,
    [KERNBASE >> PDXSHIFT] = (0) | PTE_P | PTE_W,
}
```

即不用再设置 PTE_PS 位。

> Write a user program that grows its address space with 1 byte by calling sbrk(1). Run the program and investigate the page table for the program before the call to sbrk and after the call to sbrk. How much space has the kernel allocated? What does the pte for the new memory contain?



> Modify xv6 so that the pages for the kernel are shared among processes, which reduces memory consumption.



> Modify xv6 so that when a user program dereferences a null pointer, it will receive a fault. That is, modify xv6 so that virtual address 0 isn’t mapped for user programs.

> Unix implementations of exec traditionally include special handling for shell scripts. If the file to execute begins with the text #!, then the first line is taken to be a program to run to interpret the file. For example, if exec is called to run myprog arg1 and myprog’s first line is #!/interp, then exec runs /interp with command line /interp myprog arg1. Implement support for this convention in xv6.

> Delete the check if(ph.vaddr + ph.memsz < ph.vaddr) in exec.c, and con- struct a user program that exploits that the check is missing.

> Change xv6 so that user processes run with only a minimal part of the kernel mapped and so that the kernel runs with its own page table that doesn’t include the user process.

> How would you improve xv6’s memory layout if xv6 where running on a 64-bit processor?

## Chapter 3

> Set a breakpoint at the first instruction of syscall to catch the very first system call (e.g., br syscall). What values are on the stack at this point? Explain the out- put of x/37x $esp at that breakpoint with each value labeled as to what it is (e.g., saved %ebp for trap, trapframe.eip, scratch space, etc.).

> Add a new system call to get the current UTC time and return it to the user program. You may want to use the helper function, cmostime (7552), to read the real time clock. The file date.h contains the definition of the struct rtcdate (0950), which you will provide as an argument to cmostime as a pointer.

> Write a driver for a disk that supports the SATA standard (search for SATA on the Web). Unlike IDE, SATA isn’t obsolete. Use SATA ’s tagged command queuing to issue many commands to the disk so that the disk internally can reorder commands to obtain high performance.

> Add simple driver for an Ethernet card.

## Chapter 4

> Move the acquire in iderw to before sleep. Is there a race? Why don’t you observe it when booting xv6 and run stressfs? Increase critical section with a dummy loop; what do you see now? explain.

> Remove the xchg in acquire. Explain what happens when you run xv6?

> Write a parallel program using POSIX threads, which is supported on most op- erating systems. For example, implement a parallel hash table and measure if the number of puts/gets scales with increasing number of cores.

> Implement a subset of Pthreads in xv6. That is, implement a user-level thread library so that a user process can have more than 1 thread and arrange that these threads can run in parallel on different processors. Come up with a design that cor- rectly handles a thread making a blocking system call and changing its shared address space.

## Chapter 5

> Sleep has to check lk != &ptable.lock to avoid a deadlock (2890-2893). Suppose the special case were eliminated by replacing
if(lk != &ptable.lock){ acquire(&ptable.lock); release(lk); } with release(lk); acquire(&ptable.lock); 
Doing this would break sleep. How?

> Most process cleanup could be done by either exit or wait, but we saw above that exit must not free p->stack. It turns out that exit must be the one to close the open files. Why? The answer involves pipes.

> Implement semaphores in xv6. You can use mutexes but do not use sleep and wakeup. Replace the uses of sleep and wakeup in xv6 with semaphores. Judge the result.

> Fix the race mentioned above between kill and sleep, so that a kill that occurs after the victim’s sleep loop checks p->killed but before it calls sleep results in the victim abandoning the current system call.

> Design a plan so that every sleep loop checks p->killed so that, for example, a process that is in the IDE driver can return quickly from the while loop if another kills that process.

> Design a plan that uses only one context switch when switching from one user process to another. This plan involves running the scheduler procedure on the kernel stack of the user process, instead of the dedicated scheduler stack. The main challenge is to clean up a user process correctly. Measure the performance benefit of avoiding one context switch.

> Modify xv6 to turn off a processor when it is idle and just spinning in the loop in scheduler. (Hint: look at the x86 HLT instruction.) 8. The lock p->lock protects many invariants, and when looking at a particular piece of xv6 code that is protected by p->lock, it can be difficult to figure out which invariant is being enforced. Design a plan that is more clean by perhaps splitting p- >lock in several locks.

## Chapter 6

> Why panic in balloc? Can xv6 recover?

> Why panic in ialloc? Can xv6 recover?

> Why doesn’t filealloc panic when it runs out of files? Why is this more common and therefore worth handling?

> Suppose the file corresponding to ip gets unlinked by another process between sys_link’s calls to iunlock(ip) and dirlink. Will the link be created correctly? Why or why not?

> create makes four function calls (one to ialloc and three to dirlink) that it requires to succeed. If any doesn’t, create calls panic. Why is this acceptable? Why can’t any of those four calls fail?

> sys_chdir calls iunlock(ip) before iput(cp->cwd), which might try to lock cp->cwd, yet postponing iunlock(ip) until after the iput would not cause deadlocks.Why not?

> Implement the lseek system call. Supporting lseek will also require that you modify filewrite to fill holes in the file with zero if lseek sets off beyond f->ip- >size.

> Add O_TRUNC and O_APPEND to open, so that > and >> operators work in the shell.

## Appendix B The boot loader

> Due to sector granularity, the call to readseg in the text is equivalent to read- seg((uchar*)0x100000, 0xb500, 0x1000). In practice, this sloppy behavior turns out not to be a problem Why doesn’t the sloppy readsect cause problems?

> Suppose you wanted bootmain() to load the kernel at 0x200000 instead of 0x100000, and you did so by modifying bootmain() to add 0x100000 to the va of each ELF section. Something would go wrong. What?

> It seems potentially dangerous for the boot loader to copy the ELF header to mem- ory at the arbitrary location 0x10000. Why doesn’t it call malloc to obtain the memo- ry it needs?

## 参考资料

1. 参考资料: [wikipedia:PSE](https://en.wikipedia.org/wiki/Page_Size_Extension)