---
layout: post
title: "MIT6.828 操作系统 HW:Lazy Page Allocation"
comments: true
description: "MIT6.828 操作系统 HW:Lazy Page Allocation"
keywords: "OS, assembly, c"
---

## Part One: Eliminate allocation from sbrk()

对于目前的 xv6 来说，调用 sbrk() 函数时会分配物理页和添加相应的 PTE 映射，这样我们就获得了更多的虚拟地址地址空间。可有时候分配来的空间并不会立即使用，甚至是不使用，这就造成了资源浪费。

为了避免这种情况，节省宝贵的系统资源，于是就有了 lazy allocation 的概念，要想实现 lazy allocation，就要求我们在调用 sbrk() 的时候不去真正的分配物理空间和建立 PTE 映射，只有在真正使用到相应的虚拟地址的时候才去分配。

在 OS 中，如果使用到了一块没有建立映射的虚拟地址，这时候系统会产生一个 [Page Fault](https://en.wikipedia.org/wiki/Page_fault)，我们通过这个信号来及时的为需要的地址分配物理页和建立 PTE 映射。

首先第一步，修改 `sys_sbrk()` 如下:

```
int sys_sbrk(void)
{
  int addr;
  int n;

  if (argint(0, &n) < 0)
    return -1;
  addr = myproc()->sz;
#if 0
  if (growproc(n) < 0)
    return -1;
#endif
  return addr;
}
```

这样的话，当程序申请内存的时候，只是“假装”分配内存，修改完程序，编译内核并启动，在命令行中输入 `echo hi`，得到输出如下:

```
$ echo hi
pid 3 sh: trap 14 err 6 on cpu 0 eip 0x112c addr 0x4004--kill proc
```

这段打印来自内核的 `trap.c/trap()` 函数的这段代码:

```
// In user space, assume process misbehaved.
cprintf("pid %d %s: trap %d err %d on cpu %d "
        "eip 0x%x addr 0x%x--kill proc\n",
        myproc()->pid, myproc()->name, tf->trapno,
        tf->err, cpuid(), tf->eip, rcr2());
myproc()->killed = 1;
```

需要注意的是 `rcr2()` 函数:

```
static inline uint
rcr2(void)
{
  uint val;
  asm volatile("movl %%cr2,%0" : "=r" (val));
  return val;
}
```

这个函数返回的是 [%cr2](https://en.wikipedia.org/wiki/Control_register#CR2) 寄存器内的值，这样就能知道造成 [Page Fault](https://en.wikipedia.org/wiki/Page_fault) 的是哪个虚拟地址。



## Part Two: Lazy allocation