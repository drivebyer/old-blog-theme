---
layout: post
title: "MIT6.828 操作系统 Lab2: Memory Management"
comments: true
description: "MIT6.828 操作系统 Lab2: Memory Management"
keywords: "Lab, 6.828, MIT"
---

&nbsp;

## 一、介绍

___

这个实验的目的是向 JOS 中添加内存管理，包括两部分内容：

1. physical memory allocator for the kernel，粒度为 4096B，一页(Page)的大小，我们的任务就是选用适当的数据结构来记录 Physical Page 的分配情况和有多少进程在共享这些 Physical Page。

2. virtual memory, which maps the virtual addresses used by kernel and user software to addresses in physical memory，映射通过 [MMU](https://en.wikipedia.org/wiki/Memory_management_unit) 和 [Page table](https://en.wikipedia.org/wiki/Page_table) 共同完成。

&nbsp;

## 二、准备

___

在实验之前，先看下面五个文件：

1. inc/memlayout.h
2. kern/pmap.c
3. kern/pmap.h
4. kern/kclock.h
5. kern/kclock.c

> **memlayout.h** describes the layout of the virtual address space that you must implement by modifying **pmap.c**. The code in **pmap.c** needs to read this device hardware in order to figure out how much physical memory there is, but that part of the code is done for you: you do not need to know the details of how the CMOS hardware works.

> **memlayout.h** and **pmap.h** define the **PageInfo** structure that you'll use to keep track of which pages of physical memory are free.

> **kclock.c** and **kclock.h** manipulate the PC's battery-backed clock and CMOS RAM hardware, in which the BIOS records the amount of physical memory the PC contains, among other things.

> Pay particular attention to **memlayout.h** and **pmap.h**, since this lab requires you to use and understand many of the definitions they contain. You may want to review **inc/mmu.h**, too, as it also contains a number of definitions that will be useful for this lab.

下面是 inc/memlayout.h 中设置的虚拟内存布局图例:

```
                                                Permissions
                                                kernel/user
        4 Gig -> +------------------------------+
                 |                              | RW/--
                 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
                 :            ...               :
                 |~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~| RW/--
                 |                              | RW/--
                 |   Remapped Physical Memory   | RW/--
                 |                              | RW/--
    KERNBASE, -> +------------------------------+ 0xf0000000  -----------------+
    KSTACKTOP    |     CPU0's Kernel Stack      | RW/-- KSTKSIZE(8*PGSIZE)     |
                 | - - - - - - - - - - - - - - -|                              |
                 |      Invalid Memory (*)      | --/-- KSTKGAP(8*PGSIZE)      |
                 +------------------------------+                              |
                 |     CPU1's Kernel Stack      | RW/-- KSTKSIZE               |
                 | - - - - - - - - - - - - - - -|                         PTSIZE(1024*4096B
                 |      Invalid Memory (*)      | --/-- KSTKGAP                |
                 +------------------------------+                              |
                 :              .               :                              |
      MMIOLIM -> +------------------------------+ 0xefc00000  -----------------+
                 |       Memory-mapped I/O      | RW/--  PTSIZE
ULIM,MMIOBASE -> +------------------------------+ 0xef800000      
                 |  Cur. Page Table (User R-)   | R-/R-  PTSIZE    +-------+-----+-----+
         UVPT -> +------------------------------+ 0xef400000 ----> | 0x3BD | 0x0 | 0x0 |
                 |          RO PAGES            | R-/R-  PTSIZE    +-------+-----+-----+
       UPAGES -> +------------------------------+ 0xef000000
                 |           RO ENVS            | R-/R-  PTSIZE
   UTOP,UENVS -> +------------------------------+ 0xeec00000
   UXSTACKTOP -> |     User Exception Stack     | RW/RW  PGSIZE(4096B)
                 +------------------------------+ 0xeebff000
                 |       Empty Memory (*)       | --/--  PGSIZE
    USTACKTOP -> +------------------------------+ 0xeebfe000
                 |      Normal User Stack       | RW/RW  PGSIZE
                 +------------------------------+ 0xeebfd000
                 |                              |
                 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
                 .                              .
                 |~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~|
                 |     Program Data & Heap      |
        UTEXT -> +------------------------------+ 0x00800000  ------+
                 |                              |                   |
       PFTEMP -> |       Empty Memory (*)       |                 PTSIZE
                 |                              |                   |
        UTEMP -> +------------------------------+ 0x00400000  ------+
                 |       Empty Memory (*)       |                   |
                 | - - - - - - - - - - - - - - -|                   |
                 |  User STAB Data (optional)   |                 PTSIZE
    USTABDATA -> +------------------------------+ 0x00200000        |
                 |       Empty Memory (*)       |                   |
            0 -> +------------------------------+             ------+

 (*) Note: The kernel ensures that "Invalid Memory" is *never* mapped.
     "Empty Memory" is normally unmapped, but user programs may map pages
     there if desired.  JOS user programs map pages temporarily at UTEMP.
```

为了方便找到映射关系，下面贴上物理内存布局：

```
 +---------------+ <- oxFFFFFFFF (4GB)
 |    32-bit     |
 | memory mapped |
 |    devices    |
 +---------------+
 |               |
 |    unused     |
 |               |
 +---------------+ <- depends on amont of RAM
 |    exetend    |
 |    memory     |
 +---------------+ <- 0x00100000 (1MB EXTPHYSMEM) Begin of kernel
 |    BIOS ROM   |
 +---------------+ <- 0x000F0000 (960KB)
 | 16-bot devices|
 +---------------+ <- 0x000C0000 (768KB)
 |  VGA display  |
 +---------------+ <- 0x000A0000 (640KB IOPHYSMEM)  -------------+
 |               |                                               |
 +---------------+ <- 0x00007c00 begin of bootloader        Low Memory 
 |    stack      |                                               |
 +---------------+ <- 0x00000000   ------------------------------+
```

这两张图结合 **kern/pmap.c** 文件，来完成 lab2 的练习。

&nbsp;

## 三、Physical Page Management

___

在 xv6 中，使用 **struct run** 结构体来描述物理页，而在 JOS 中，则使用 **struct PageInfo** 来描述，并且与 xv6 不同的是，**struct PageInfo** 没有内嵌到 free page 中。

通过操作 **struct PageInfo** 这个数据结构，来完成 **Physical Page Allocator**。

需要实现以下几个函数:

1. boot_alloc()
2. mem_init()
3. page_init()
4. page_alloc()
5. page_free()

### 3.1 boot_alloc()

> This simple physical memory allocator is used only while JOS is setting
up its virtual memory system.  **page_alloc()** is the real allocator.
If **n>0**, allocates enough pages of contiguous physical memory to hold 'n'
bytes.  **Doesn't initialize the memory.  Returns a kernel virtual address**.
If **n==0**, returns the address of the next free page without allocating
anything. 
If we're out of memory, boot_alloc should panic.
This function may **ONLY** be used during initialization,
before the page_free_list list has been set up.

```
static void *
boot_alloc(uint32_t n)
{
	static char *nextfree;	// virtual address of next byte of free memory
	char *result;

	if (!nextfree) {
		extern char end[]; /*这个值在kernel.ld中定义，是虚拟地址*/
		nextfree = ROUNDUP((char *) end, PGSIZE); // 
	}

	if (n > 0) {
		result = nextfree; 
		nextfree = ROUNDUP(nextfree + n, PGSIZE);
		if ((uint32_t)nextfree / 1024 / PGSIZE > npages)
			panic("boot_alloc out of memory");
		return result; 
	}
	if (n == 0)
		return nextfree;
	return NULL;
}
```

注意虽然分配了物理页，但是应该返回分配前的地址。且返回的是虚拟地址。

在 kernel.ld 中定义了 end 的值，这个值是一个虚拟地址，而 nextfree 的初始值又是根据 end 得来的，所以 nextfree 也是一个虚拟地址，也可以这么说，虽然我们是在分配物理内存，但是操作的地址只能是虚拟地址，这是因为 kernel 本质上也是一个软件（特殊的软件），在计算机中软件使用的地址都是虚拟地址。

到目前为止，唯一需要用到物理地址的地方就是设置 **PDE** 和 **PTE** 的时候，他们的前20位（PPN）只能存放物理地址。

### 3.2 mem_init()

> Set up a two-level page table:
 kern_pgdir is its linear (virtual) address of the root
 This function only sets up the kernel part of the address space
 (ie. addresses >= UTOP).  The user part of the address space
 will be set up later.
 From UTOP to ULIM, the user is allowed to read but not write.
 Above ULIM the user cannot read or write.

这里可以看到，在 xv6 中，KERNBASE 以上都是属于 **kernel part of the address space**，而在 JOS 中则不是这样。

在 xv6 中已经学到，每个进程中的 kernel 部分的映射都是一样的，所以这里先设置 kernel 部分的映射，即设置 kernel 部分的 Page Directory 和 Page Table。

```
//////////////////////////////////////////////////////////////////////
// create initial page directory.
kern_pgdir = (pde_t *) boot_alloc(PGSIZE); /*分配一页物理内存存放Page Directory*/
memset(kern_pgdir, 0, PGSIZE);
```

这是 **mem_init()** 中第一次使用 **boot_alloc()**，所以 Page Directory 在物理内存上紧跟在 kernel 的后面。

```
//////////////////////////////////////////////////////////////////////
// Allocate an array of npages 'struct PageInfo's and store it in 'pages'.
// The kernel uses this array to keep track of physical pages: for
// each physical page, there is a corresponding struct PageInfo in this
// array.  'npages' is the number of physical pages in memory.  Use memset
// to initialize all fields of each struct PageInfo to 0.
// Your code goes here:

pages = (struct PageInfo *)boot_alloc(npages * sizeof(struct PageInfo));
memset(pages, 0, npages * sizeof(struct PageInfo));
```

这是第二次使用 **boot_alloc()**，紧跟在 Page Directory 后面分配了 npages*6B 大小的物理内存，用来存放物理页的分配情况 **PageInfo**，注意这个函数还有一部分会在后面完成。

### 3.3 page_init()

> Tracking of physical pages.
The **'pages'** array has one 'struct PageInfo' entry per physical page.
Pages are reference counted, and free pages are kept on a linked list(**page_free_list**).
Initialize page structure and memory free list.
After this is done, **NEVER use boot_alloc again**.  ONLY use the page
allocator functions below to allocate and deallocate physical
memory via the page_free_list.

按照下面的步骤完成函数：

1. Mark physical page 0 as in use.This way we preserve the real-mode IDT and BIOS structures in case we ever need them.  (Currently we don't, but...)
2. The rest of base memory, [PGSIZE, npages_basemem * PGSIZE) is free.
3. Then comes the IO hole [IOPHYSMEM, EXTPHYSMEM), which must never be allocated.
4. Then extended memory [EXTPHYSMEM, ...). Some of it is in use, some is free. Where is the kernel in physical memory?  Which pages are already in use for page tables and other data structures?

NB: DO NOT actually touch the physical memory corresponding to free pages!

根据上面的步骤，我画了一个简易的物理内存的使用图（until now）：

```
+------------------+
|        ...       |
|    not allocat   |
+------------------+ <- boot_alloc(0) - KERNBASE
| npage * PageInfo | 
+------------------+ <- pages，这段内存会映射到虚拟内存[UPAGES, UVPT]
|  Page Directory  |
+------------------+ <- end - KERNBASE
|      kernel      |
+------------------+ <- EXTPHYSMEM
|     I/O hole     |
+------------------+ <- IOPHYSMEM
|   Base memory    |
+------------------+
```

pages 这块内存里的 PageInfo 数组，描述了整个物理内存的 Page 分配情况。

npage * PageInfo =32768 * 6B=196608B，而[UPAGES, UVPT]大小为 1024 * 4096B=4194304B，4194304B>>>196608B，空间是足够的。

根据上面的内存使用情况，分别初始化，代码如下：

```
void
page_init(void)
{
	size_t i;
	pages[0].pp_ref = 1; /*将第0页标记为使用*/
	for (i = 1; i < npages_basemem; i++)
	{
		pages[i].pp_ref = 0;
		pages[i].pp_link = page_free_list;
		page_free_list = &pages[i];
	}
	for (i = EXTPHYSMEM / PGSIZE; i < (uint32_t)boot_alloc(0) / PGSIZE; i++)
		pages[i].pp_ref = 1;	
	for (i = PADDR((uint32_t)boot_alloc(0)) / PGSIZE; i < npages; i++)
	{
		pages[i].pp_ref = 0;
		pages[i].pp_link = page_free_list;
		page_free_list = &pages[i];		
	}
}
```

注意通过 boot_alloc(0) 得到的是虚拟地址，需要将其转换成物理地址使用。

### 3.4 page_alloc()

> Allocates a physical page.  If (alloc_flags & ALLOC_ZERO), fills the entire
returned physical page with '\0' bytes.  Does NOT increment the reference
count of the page - the caller must do these if necessary (either explicitly
or via page_insert).
Be sure to set the pp_link field of the allocated page to NULL so
page_free can check for double-free bugs.
Returns NULL if out of free memory.
Hint: use page2kva and memset

为了能更加直观看出内存的分布情况，将内存中 **pages** 部分放大来看，就是下面这样：

```
+------------------+
|      ...         |
|  not allocated   |
+------------------+ --------------+
|      ......      |               |
+------------------+ ----+         |
|     pp_link      |     |         |
+------------------+     1         |
|  pp_ref |  ...   |     |         |-> 这段内存映射到虚拟内存[UPAGES, UVPT]
+------------------+ ----+         |
|     pp_link      |     |         |
+------------------+     0         |
|  pp_ref |  ...   |     |         |
+------------------+ <---+-pages---+
|  Page Directory  |
+------------------+ <- end - KERNBASE
|      kernel      |
+------------------+ <- EXTPHYSMEM(1MB)
|       ...        |
+------------------+
|  Page 1 for free |
+------------------+
|  Page 0 in use   |
+------------------+
```

标记 0 处的 **PageInfo** 描述了 Page 0 的使用情况，标记 1 处的 **PageInfo** 描述了 Page 1 的使用情况，以此类推...

```
struct PageInfo *
page_alloc(int alloc_flags)
{
	struct PageInfo *return_page;
	/*分配一个物理页*/
	return_page = page_free_list; /*返回链表头*/
	if (alloc_flags & ALLOC_ZERO)
	{
		/*memset为内核函数，需要操作虚拟地址*/
		memset(page2kva(return_page), 0, PGSIZE);
	}
	page_free_list = return_page->pp_link; /**/
	return_page->pp_link = NULL; /*从空闲链表中移除*/

	if (!page_free_list)
		return NULL;

	return return_page;
}
```

### 3.5 page_free()









