---
layout: post
title: "MIT6.828 操作系统 Lab2: Memory Management"
comments: true
description: "MIT6.828 操作系统 Lab2: Memory Management"
keywords: "Lab, 6.828, MIT"
---

&nbsp;

## 一、介绍

___

这个实验的目的是向 JOS 中添加内存管理，包括两部分内容：

1. physical memory allocator for the kernel，粒度为 4096B，一页(Page)的大小，我们的任务就是选用适当的数据结构来记录 Physical Page 的分配情况和有多少进程在共享这些 Physical Page。

2. virtual memory, which maps the virtual addresses used by kernel and user software to addresses in physical memory，映射通过 [MMU](https://en.wikipedia.org/wiki/Memory_management_unit) 和 [Page table](https://en.wikipedia.org/wiki/Page_table) 共同完成。

&nbsp;

## 二、准备

___

在实验之前，先看下面五个文件：

1. inc/memlayout.h
2. kern/pmap.c
3. kern/pmap.h
4. kern/kclock.h
5. kern/kclock.c

> **memlayout.h** describes the layout of the virtual address space that you must implement by modifying **pmap.c**. The code in **pmap.c** needs to read this device hardware in order to figure out how much physical memory there is, but that part of the code is done for you: you do not need to know the details of how the CMOS hardware works.

> **memlayout.h** and **pmap.h** define the **PageInfo** structure that you'll use to keep track of which pages of physical memory are free.

> **kclock.c** and **kclock.h** manipulate the PC's battery-backed clock and CMOS RAM hardware, in which the BIOS records the amount of physical memory the PC contains, among other things.

> Pay particular attention to **memlayout.h** and **pmap.h**, since this lab requires you to use and understand many of the definitions they contain. You may want to review **inc/mmu.h**, too, as it also contains a number of definitions that will be useful for this lab.

下面是 inc/memlayout.h 中设置的虚拟内存布局图例:

```
                                                Permissions
                                                kernel/user
        4 Gig -> +------------------------------+
                 |                              | RW/--
                 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
                 :            ...               :
                 |~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~| RW/--
                 |                              | RW/--
                 |   Remapped Physical Memory   | RW/--
                 |                              | RW/--
    KERNBASE, -> +------------------------------+ 0xf0000000  -----------------+
    KSTACKTOP    |     CPU0's Kernel Stack      | RW/-- KSTKSIZE(8*PGSIZE)     |
                 | - - - - - - - - - - - - - - -|                              |
                 |      Invalid Memory (*)      | --/-- KSTKGAP(8*PGSIZE)      |
                 +------------------------------+                              |
                 |     CPU1's Kernel Stack      | RW/-- KSTKSIZE               |
                 | - - - - - - - - - - - - - - -|                         PTSIZE(1024*4096B
                 |      Invalid Memory (*)      | --/-- KSTKGAP                |
                 +------------------------------+                              |
                 :              .               :                              |
      MMIOLIM -> +------------------------------+ 0xefc00000  -----------------+
                 |       Memory-mapped I/O      | RW/--  PTSIZE
ULIM,MMIOBASE -> +------------------------------+ 0xef800000      
                 |  Cur. Page Table (User R-)   | R-/R-  PTSIZE    +-------+-----+-----+
         UVPT -> +------------------------------+ 0xef400000 ----> | 0x3BD | 0x0 | 0x0 |
                 |          RO PAGES            | R-/R-  PTSIZE    +-------+-----+-----+
       UPAGES -> +------------------------------+ 0xef000000
                 |           RO ENVS            | R-/R-  PTSIZE
   UTOP,UENVS -> +------------------------------+ 0xeec00000
   UXSTACKTOP -> |     User Exception Stack     | RW/RW  PGSIZE(4096B)
                 +------------------------------+ 0xeebff000
                 |       Empty Memory (*)       | --/--  PGSIZE
    USTACKTOP -> +------------------------------+ 0xeebfe000
                 |      Normal User Stack       | RW/RW  PGSIZE
                 +------------------------------+ 0xeebfd000
                 |                              |
                 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
                 .                              .
                 |~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~|
                 |     Program Data & Heap      |
        UTEXT -> +------------------------------+ 0x00800000  ------+
                 |                              |                   |
       PFTEMP -> |       Empty Memory (*)       |                 PTSIZE
                 |                              |                   |
        UTEMP -> +------------------------------+ 0x00400000  ------+
                 |       Empty Memory (*)       |                   |
                 | - - - - - - - - - - - - - - -|                   |
                 |  User STAB Data (optional)   |                 PTSIZE
    USTABDATA -> +------------------------------+ 0x00200000        |
                 |       Empty Memory (*)       |                   |
            0 -> +------------------------------+             ------+

 (*) Note: The kernel ensures that "Invalid Memory" is *never* mapped.
     "Empty Memory" is normally unmapped, but user programs may map pages
     there if desired.  JOS user programs map pages temporarily at UTEMP.
```

为了方便找到映射关系，下面贴上物理内存布局：

```
 +---------------+ <- oxFFFFFFFF (4GB)
 |    32-bit     |
 | memory mapped |
 |    devices    |
 +---------------+
 |               |
 |    unused     |
 |               |
 +---------------+ <- depends on amont of RAM
 |    exetend    |
 |    memory     |
 +---------------+ <- 0x00100000 (1MB EXTPHYSMEM) Begin of kernel
 |    BIOS ROM   |
 +---------------+ <- 0x000F0000 (960KB)
 | 16-bot devices|
 +---------------+ <- 0x000C0000 (768KB)
 |  VGA display  |
 +---------------+ <- 0x000A0000 (640KB IOPHYSMEM)  -------------+
 |               |                                               |
 +---------------+ <- 0x00007c00 begin of bootloader        Low Memory 
 |    stack      |                                               |
 +---------------+ <- 0x00000000   ------------------------------+
```

这两张图结合 **kern/pmap.c** 文件，来完成 lab2 的练习。

&nbsp;

## 三、Physical Page Management

___

在 xv6 中，使用 **struct run** 结构体来描述物理页，而在 JOS 中，则使用 **struct PageInfo** 来描述，并且与 xv6 不同的是，**struct PageInfo** 没有内嵌到 free page 中。

通过操作 **struct PageInfo** 这个数据结构，来完成 **Physical Page Allocator**。

需要实现以下几个函数:

1. boot_alloc()
2. mem_init()
3. page_init()
4. page_alloc()
5. page_free()

### 3.1 boot_alloc()

> This simple physical memory allocator is used only while JOS is setting
up its virtual memory system.  **page_alloc()** is the real allocator.
If **n>0**, allocates enough pages of contiguous physical memory to hold 'n'
bytes.  **Doesn't initialize the memory.  Returns a kernel virtual address**.
If **n==0**, returns the address of the next free page without allocating
anything. 
If we're out of memory, boot_alloc should panic.
This function may **ONLY** be used during initialization,
before the page_free_list list has been set up.

```
static void *
boot_alloc(uint32_t n)
{
	static char *nextfree;	// virtual address of next byte of free memory
	char *result;

	if (!nextfree) {
		extern char end[]; /*这个值在kernel.ld中定义，是虚拟地址*/
		nextfree = ROUNDUP((char *) end, PGSIZE); // 
	}

	if (n > 0) {
		result = nextfree; 
		nextfree = ROUNDUP(nextfree + n, PGSIZE);
		if ((uint32_t)nextfree / 1024 / PGSIZE > npages)
			panic("boot_alloc out of memory");
		return result; 
	}
	if (n == 0)
		return nextfree;
	return NULL;
}
```

注意虽然分配了物理页，但是应该返回分配前的地址。且返回的是虚拟地址。

在 kernel.ld 中定义了 end 的值，这个值是一个虚拟地址，而 nextfree 的初始值又是根据 end 得来的，所以 nextfree 也是一个虚拟地址，也可以这么说，虽然我们是在分配物理内存，但是操作的地址只能是虚拟地址，这是因为 kernel 本质上也是一个软件（特殊的软件），在计算机中软件使用的地址都是虚拟地址。

到目前为止，唯一需要用到物理地址的地方就是设置 **PDE** 和 **PTE** 的时候，他们的前20位（PPN）只能存放物理地址。

### 3.2 mem_init()

> Set up a two-level page table:
 kern_pgdir is its linear (virtual) address of the root
 This function only sets up the kernel part of the address space
 (ie. addresses >= UTOP).  The user part of the address space
 will be set up later.
 From UTOP to ULIM, the user is allowed to read but not write.
 Above ULIM the user cannot read or write.

这里可以看到，在 xv6 中，KERNBASE 以上都是属于 **kernel part of the address space**，而在 JOS 中则不是这样。

在 xv6 中已经学到，每个进程中的 kernel 部分的映射都是一样的，所以这里先设置 kernel 部分的映射，即设置 kernel 部分的 Page Directory 和 Page Table。

```
void
mem_init(void)
{
	uint32_t cr0;
	size_t n;
    // Find out how much memory the machine has (npages & npages_basemem).
	i386_detect_memory();

	// Remove this line when you're ready to test this function.
	panic("mem_init: This function is not finished\n");

	//////////////////////////////////////////////////////////////////////
	// create initial page directory.
	kern_pgdir = (pde_t *) boot_alloc(PGSIZE);
	memset(kern_pgdir, 0, PGSIZE);

	//////////////////////////////////////////////////////////////////////
	// Recursively insert PD in itself as a page table, to form
	// a virtual page table at virtual address UVPT.
	// (For now, you don't have understand the greater purpose of the
	// following line.)

	// Permissions: kernel R, user R
	kern_pgdir[PDX(UVPT)] = PADDR(kern_pgdir) | PTE_U | PTE_P;

	//////////////////////////////////////////////////////////////////////
	// Allocate an array of npages 'struct PageInfo's and store it in 'pages'.
	// The kernel uses this array to keep track of physical pages: for
	// each physical page, there is a corresponding struct PageInfo in this
	// array.  'npages' is the number of physical pages in memory.  Use memset
	// to initialize all fields of each struct PageInfo to 0.
	// Your code goes here:


	//////////////////////////////////////////////////////////////////////
	// Now that we've allocated the initial kernel data structures, we set
	// up the list of free physical pages. Once we've done so, all further
	// memory management will go through the page_* functions. In
	// particular, we can now map memory using boot_map_region
	// or page_insert
	page_init();

	check_page_free_list(1);
	check_page_alloc();
	check_page();

	//////////////////////////////////////////////////////////////////////
	// Now we set up virtual memory

	//////////////////////////////////////////////////////////////////////
	// Map 'pages' read-only by the user at linear address UPAGES
	// Permissions:
	//    - the new image at UPAGES -- kernel R, user R
	//      (ie. perm = PTE_U | PTE_P)
	//    - pages itself -- kernel RW, user NONE
	// Your code goes here:

	//////////////////////////////////////////////////////////////////////
	// Use the physical memory that 'bootstack' refers to as the kernel
	// stack.  The kernel stack grows down from virtual address KSTACKTOP.
	// We consider the entire range from [KSTACKTOP-PTSIZE, KSTACKTOP)
	// to be the kernel stack, but break this into two pieces:
	//     * [KSTACKTOP-KSTKSIZE, KSTACKTOP) -- backed by physical memory
	//     * [KSTACKTOP-PTSIZE, KSTACKTOP-KSTKSIZE) -- not backed; so if
	//       the kernel overflows its stack, it will fault rather than
	//       overwrite memory.  Known as a "guard page".
	//     Permissions: kernel RW, user NONE
	// Your code goes here:

	//////////////////////////////////////////////////////////////////////
	// Map all of physical memory at KERNBASE.
	// Ie.  the VA range [KERNBASE, 2^32) should map to
	//      the PA range [0, 2^32 - KERNBASE)
	// We might not have 2^32 - KERNBASE bytes of physical memory, but
	// we just set up the mapping anyway.
	// Permissions: kernel RW, user NONE
	// Your code goes here:

	// Check that the initial page directory has been set up correctly.
	check_kern_pgdir();

	// Switch from the minimal entry page directory to the full kern_pgdir
	// page table we just created.	Our instruction pointer should be
	// somewhere between KERNBASE and KERNBASE+4MB right now, which is
	// mapped the same way by both page tables.
	//
	// If the machine reboots at this point, you've probably set up your
	// kern_pgdir wrong.
	lcr3(PADDR(kern_pgdir));

	check_page_free_list(0);

	// entry.S set the really important flags in cr0 (including enabling
	// paging).  Here we configure the rest of the flags that we care about.
	cr0 = rcr0();
	cr0 |= CR0_PE|CR0_PG|CR0_AM|CR0_WP|CR0_NE|CR0_MP;
	cr0 &= ~(CR0_TS|CR0_EM);
	lcr0(cr0);

	// Some more checks, only possible after kern_pgdir is installed.
	check_page_installed_pgdir();
}
```
### 3.3 page_init()

> Tracking of physical pages.
The **'pages'** array has one 'struct PageInfo' entry per physical page.
Pages are reference counted, and free pages are kept on a linked list(**page_free_list**).
Initialize page structure and memory free list.
After this is done, **NEVER use boot_alloc again**.  ONLY use the page
allocator functions below to allocate and deallocate physical
memory via the page_free_list.

按照下面的步骤完成函数：

1. Mark physical page 0 as in use.This way we preserve the real-mode IDT and BIOS structures in case we ever need them.  (Currently we don't, but...)
2. The rest of base memory, [PGSIZE, npages_basemem * PGSIZE) is free.
3. Then comes the IO hole [IOPHYSMEM, EXTPHYSMEM), which must never be allocated.
4. Then extended memory [EXTPHYSMEM, ...). Some of it is in use, some is free. Where is the kernel in physical memory?  Which pages are already in use for page tables and other data structures?

NB: DO NOT actually touch the physical memory corresponding to free pages!

根据上面的步骤，我画了一个简易的物理内存的使用图：

```
+------------------+
|        ...       |
|    not allocat   |
+------------------+ <- boot_alloc(0) - KERNBASE
| npage * PageInfo |  
+------------------+
|  Page Directory  |
+------------------+ <- end - KERNBASE
|      kernel      |
+------------------+ <- EXTPHYSMEM
|     I/O hole     |
+------------------+ <- IOPHYSMEM
|   Base memory    |
+------------------+

```

```
void
page_init(void)
{
	size_t i;
	pages[0].pp_ref = 1; /*将第0页标记为使用*/
	for (i = 1; i < npages_basemem; i++)
	{
		pages[i].pp_ref = 0;
		pages[i].pp_link = page_free_list;
		page_free_list = &pages[i];
	}
	for (i = EXTPHYSMEM / PGSIZE; i < (uint32_t)boot_alloc(0) / PGSIZE; i++)
		pages[i].pp_ref = 1;	
	for (i = PADDR((uint32_t)boot_alloc(0)) / PGSIZE; i < npages; i++)
	{
		pages[i].pp_ref = 0;
		pages[i].pp_link = page_free_list;
		page_free_list = &pages[i];		
	}
}
```

### 3.4 page_alloc()

### 3.5 page_free()









