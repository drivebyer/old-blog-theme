---
layout: post
title: "MIT6.828 操作系统 Lab1:Memory Management"
comments: true
description: "MIT6.828 操作系统 Lab1:Memory Management"
keywords: "Lab, 6.828, MIT"
---

## 介绍

这个实验的目的是向 JOS 中添加内存管理，包括两部分内容：

1. physical memory allocator for the kernel，粒度为 4096B，一页(Page)的大小，我们的任务就是选用适当的数据结构来记录 Physical Page 的分配情况和有多少进程在共享这些 Physical Page。

2. virtual memory, which maps the virtual addresses used by kernel and user software to addresses in physical memory，映射通过 [MMU](https://en.wikipedia.org/wiki/Memory_management_unit) 和 [Page table](https://en.wikipedia.org/wiki/Page_table) 共同完成。

## 准备

在实验之前，先看下面五个文件：

1. inc/memlayout.h
2. kern/pmap.c
3. kern/pmap.h
4. kern/kclock.h
5. kern/kclock.c

> **memlayout.h** describes the layout of the virtual address space that you must implement by modifying **pmap.c**. The code in **pmap.c** needs to read this device hardware in order to figure out how much physical memory there is, but that part of the code is done for you: you do not need to know the details of how the CMOS hardware works.

> **memlayout.h** and **pmap.h** define the **PageInfo** structure that you'll use to keep track of which pages of physical memory are free.

> **kclock.c** and **kclock.h** manipulate the PC's battery-backed clock and CMOS RAM hardware, in which the BIOS records the amount of physical memory the PC contains, among other things.

> Pay particular attention to **memlayout.h** and **pmap.h**, since this lab requires you to use and understand many of the definitions they contain. You may want to review **inc/mmu.h**, too, as it also contains a number of definitions that will be useful for this lab.

## Part1: Physical Page Management

在 xv6 中，使用 **struct run** 结构体来描述物理页，而在 JOS 中，则使用 **struct PageInfo** 来描述，并且与 xv6 不同的是，**struct PageInfo** 没有内嵌到 free page 中。