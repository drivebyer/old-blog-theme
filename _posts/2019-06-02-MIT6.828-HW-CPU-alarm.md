---
layout: post
title: "MIT6.828 操作系统 HW: CPU alarm"
comments: true
description: "MIT6.828 操作系统 HW: CPU alarm"
keywords: "OS, assembly, c"
---

> In this exercise you'll add a feature to xv6 that periodically alerts a process as it uses CPU time. This might be useful for **compute-bound processes** that want to limit how much CPU time they chew up, or for processes that want to compute but also want to take some periodic action.

添加一个系统调用：**alarm(interval, handler)**。

> If an application calls alarm(n, fn), then after every n "ticks" of CPU time that the program consumes, the kernel will cause application function fn to be called. When fn returns, the application will resume where it left off.

> A tick is a fairly arbitrary unit of time in xv6, determined by how often a hardware timer generates interrupts.

添加一个用户程序 **alarmtest.c**，代码如下：

```
#include "types.h"
#include "stat.h"
#include "user.h"

void periodic();

int
main(int argc, char *argv[])
{
  int i;
  printf(1, "alarmtest starting\n");
  alarm(10, periodic);
  for(i = 0; i < 25*500000; i++){
    if((i % 250000) == 0)
      write(2, ".", 1);
  }
  exit();
}

void
periodic()
{
  printf(1, "alarm!\n");
}
```

> The program calls **alarm(10, periodic)** to ask the kernel to force a call to periodic() every 10 ticks, and then spins for a while. 

大致步骤同前一个作业[HW: System Calls](https://wuyang.me/2019/MIT6.828-HW-System-Calls/)的实现：

> Hint: you'll need to modify the Makefile to cause alarmtest.c to be compiled as an xv6 user program.

```
UPROGS=\
	_cat\
	_echo\
	_forktest\
	_grep\
	_init\
	_kill\
	_ln\
	_ls\
	_mkdir\
	_rm\
	_sh\
	_stressfs\
	_usertests\
	_wc\
	_zombie\
	_date\
	_alarmtest\
```

> Hint: put the right declaration in **user.h**

```
int alarm(int ticks, void (*handler)());
```

> Hint: You will also have to update syscall.h and usys.S to allow alarmtest to invoke the alarm system call.

在 syscall.h 中添加：

```
#define SYS_alarm  23
```

在 usys.S 中添加：

```
SYSCALL(alarm)
```

> Hint: Your sys_alarm() should store the alarm interval and the pointer to the handler function in new fields in the proc structure; see proc.h.



