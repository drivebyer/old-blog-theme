---
layout: post
title: "MIT6.828 操作系统 HW: CPU alarm"
comments: true
description: "MIT6.828 操作系统 HW: CPU alarm"
keywords: "OS, assembly, c"
---

> In this exercise you'll add a feature to xv6 that periodically alerts a process as it uses CPU time. This might be useful for **compute-bound processes** that want to limit how much CPU time they chew up, or for processes that want to compute but also want to take some periodic action.

添加一个系统调用：**alarm(interval, handler)**。

> If an application calls alarm(n, fn), then after every n "ticks" of CPU time that the program consumes, the kernel will cause application function fn to be called. When fn returns, the application will resume where it left off.

> A tick is a fairly arbitrary unit of time in xv6, determined by how often a hardware timer generates interrupts.

添加一个用户程序 **alarmtest.c**，代码如下：

```
#include "types.h"
#include "stat.h"
#include "user.h"

void periodic();

int
main(int argc, char *argv[])
{
  int i;
  printf(1, "alarmtest starting\n");
  alarm(10, periodic);
  for(i = 0; i < 25*500000; i++){
    if((i % 250000) == 0)
      write(2, ".", 1);
  }
  exit();
}

void
periodic()
{
  printf(1, "alarm!\n");
}
```

> The program calls **alarm(10, periodic)** to ask the kernel to force a call to periodic() every 10 ticks, and then spins for a while. 

大致步骤同前一个作业[HW: System Calls](https://wuyang.me/2019/MIT6.828-HW-System-Calls/)的实现：

> you'll need to modify the Makefile to cause alarmtest.c to be compiled as an xv6 user program.

```
UPROGS=\
	_cat\
	_echo\
	_forktest\
	_grep\
	_init\
	_kill\
	_ln\
	_ls\
	_mkdir\
	_rm\
	_sh\
	_stressfs\
	_usertests\
	_wc\
	_zombie\
	_date\
	_alarmtest\
```

> put the right declaration in **user.h**

```
int alarm(int ticks, void (*handler)());
```

> You will also have to update syscall.h and usys.S to allow alarmtest to invoke the alarm system call.

在 syscall.h 中添加：

```
#define SYS_alarm  23
```

在 usys.S 中添加：

```
SYSCALL(alarm)
```

> Your sys_alarm() should store the alarm interval and the pointer to the handler function in new fields in the proc structure; see proc.h.

在 **struct proc** 中添加两个成员：

```
// add for alarmtest.c
int alarmticks;
void (*alarmhandler)();
```

并在 **sysproc.c** 中添加如下代码：

```
int
sys_alarm(void)
{
  int ticks;
  void (*handler)();
  if(argint(0, &ticks) < 0)
    return -1;
  if(argptr(1, (char**)&handler, 1) < 0)
    return -1;
  /*获取到alarm()系统调用参数后，将其赋值给当前进程的成员*/
  myproc()->alarmticks = ticks;
  myproc()->alarmhandler = handler;
  return 0;
}
```

> Add an entry for **SYS_ALARM** to the syscalls arrays in **syscall.c**

```
extern int sys_alarm(void);
```

```
[SYS_alarm] sys_alarm
```

> You'll need to keep track of how many ticks have passed since the last call (or are left until the next call) to a process's alarm handler; you'll need a new field in struct proc for this too. You can initialize proc fields in allocproc() in proc.c.

再在 **struct proc** 结构体中添加一个成员：

```
int tick_counts;
```

并且选择在 **proc.c/allocproc()** 中初始化这个成员：

```
p->tick_counts = 0;
```

> Every tick, the hardware clock forces an interrupt, which is handled in trap() by case T_IRQ0 + IRQ_TIMER; you should add some code here.

在上面的 case 子句里处理 timer interrupt。

到这里我们可以梳理一下这个作业要求的整个脉络，首先在用户程序 alarmtest 里执行一个系统调用 alarm()，该系统调用的最终目的就是在 sys_alarm() 函数里，将系统调用的两个参数保存进 struct proc 结构体，最后结束系统调用，返回到用户态。这一步的目的是为 timer interrupt 准备一些数据。

剩下的就是通过 timer interrupt 来定时的提醒 kernel 去调用一个函数，这个函数是通过 alarm() 第二个参数指定的，是一个用户态函数。

kernel 通过在 trap() 函数的 case 子句（如下）里添加相应的处理，来达到定时调用的目的。

```
+-----+    trap      +------------------------+
| for |------------> |timer interrupt hanlder |  
+-----+              +------------------------+
   ^                         |
   |                         |
+----------+                 |
| periodic | <---------------+ 
+----------+
```

整个处理顺序大致如上，在执行 for 循环的时候，接受到硬件中断timer interrupt，陷入后，执行对应的 case 子句，case 子句将用户态的返回点换成绑定的 periodic() 函数，执行完此函数后，再接着 for 语句执行，后面就是反复的执行这几步。

```
case T_IRQ0 + IRQ_TIMER:
  if(cpuid() == 0){
    acquire(&tickslock);
    ticks++;
    wakeup(&ticks);
    release(&tickslock);
  }
  lapiceoi();
  break;
```

注意系统调用是可以被硬件中断打断的。

