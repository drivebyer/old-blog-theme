---
layout: post
title: "MIT6.828 操作系统 Lab3: User Environment"
comments: true
description: "MIT6.828 操作系统 Lab3: User Environment"
keywords: "OS, assembly, c"
---

&nbsp;

## 一、Introduction

___

这个实验是向 JOS 中添加功能以支持 User Environment（即 Unix 中的进程）。

注意: 在实验过程中，术语 **environment** 和 **process** 是等价的，都是对用户程序的一种抽象。在 JOS 中使用 **environment**，是为了和传统的 UNIX 中的 **process** 进行区分，它们在接口和语义上有点区别。

But，由于翻译过中文 **"环境"** 这个词听着实在别扭，以后的实验中有时候还是将 **environment** 称作进程。

### 1.1、Getting Started

先合并代码：

```
linux> cd ~/6.828/lab
linux> git commit -m "change"
linux> git pull
linux> git checkout -b lab3 origin/lab3
linux> git checkout lab1
linux> git merge lab3 
```

由于我是在 lab1 分之上做的开发，所以合并前需要切换到 lab1 分支。

下面是本实验需要用到的一些文件说明，大致浏览一下即可：

1.  **inc/env.h**  Public definitions for user-mode environments
2.  **trap.h**  Public definitions for trap handling
3.  **syscall.h**  Public definitions for system calls from user environments to the kernel
4.  **lib.h**  Public definitions for the user-mode support library
5.  **kern/env.h**  Kernel-private definitions for user-mode environments
6.  **env.c**  Kernel code implementing user-mode environments
7.  **trap.h**  Kernel-private trap handling definitions
8.  **trap.c**  Trap handling code
9.  **trapentry.S**  Assembly-language trap handler entry-points
10. **syscall.h**  Kernel-private definitions for system call handling
11. **syscall.c**  System call implementation code
12. **lib/Makefrag**  Makefile fragment to build user-mode library, obj/lib/libjos.a
13. **entry.S**  Assembly-language entry-point for user environments
14. **libmain.c**  User-mode library setup code called from entry.S
15. **syscall.c**  User-mode system call stub functions
16. **console.c**  User-mode implementations of putchar and getchar, providing console I/O
17. **exit.c**  User-mode implementation of exit
18. **panic.c**  User-mode implementation of panic
19. **user/**  Various test programs to check kernel lab 3 code

### 1.2、Inline Assembly

这个 lab 里很多地方会使用到内联汇编，下面是一些参考资料：

1. [Inline assembly for x86 in Linux](https://www.ibm.com/developerworks/linux/library/l-ia/index.html)
2. [Brennan's Guide to Inline Assembly](http://www.delorie.com/djgpp/doc/brennan/brennan_att_inline_djgpp.html)
3. [GCC Inline Assembly HOWTO](http://www.ibiblio.org/gferg/ldp/GCC-Inline-Assembly-HOWTO.html)
4. [内联汇编初探](https://wuyang.me/2019/%E5%86%85%E8%81%94%E6%B1%87%E7%BC%96%E5%88%9D%E6%8E%A2/)

&nbsp;

## 二、Part A: User Environment and Exception Handling

___

在文件 **inc/env.h** 中包括了一些重要的定义，最好能提前阅读一下。其中 **Env** 这个数据结构用来描述 **user environment** 的概念，这个实验要求能创建一个 **environment**，并支持多个 **environment**。


在 **kern/env.c** 中, kernel 使用了 3 个全局变量来描述记录 environments:

```
struct Env *envs = NULL;		   // All environments
struct Env *curenv = NULL;		   // The current env
static struct Env *env_free_list;  // Free environment list
					               // (linked by Env->env_link)
```

当 JOS 启动后, **envs** 指向一个 **Env** 结构体数组，表示系统中所有的环境（environment）。在我们的设计中，JOS 支持最多 **NENV**（see blow） 个进程同时活动。

```
#define LOG2NENV		10
#define NENV			(1 << LOG2NENV)
```

JOS 将所有不活动的进程放到 **env_free_list** 链表中。

JOS 使用 **curenv** 来表示当前正在执行的进程。系统刚启动时，**curenv** 被初始化为 **NULL**。

### 2.1、Environment State

下面是 **Env** 结构体，随着实验的进行，会向里面添加更多的成员。

```
struct Env {
	struct Trapframe env_tf; // Saved registers
	struct Env *env_link;	   // Next free Env
	envid_t env_id;			     // Unique environment identifier
	envid_t env_parent_id;	 // env_id of this env's parent
	enum EnvType env_type;	 // Indicates special system environments
	unsigned env_status;	   // Status of the environment
	uint32_t env_runs;	 	   // Number of times environment has run
	// Address space 
	pde_t *env_pgdir;	    	 // Kernel virtual address of page dir
};
```

下面是成员进行说明：

1. **env_tf**: 这里的 Trapframe 结构体与 xv6 中的 trapframe 是类似，当进程不运行的时候（i.e.,需要系统中另一个进程运行 or 此进程陷入内核），kernel 把当前进程相关的寄存器保存进 Trapframe，以便后面 restore 时使用。
2. **env_link**: 指向空闲进程链表 env_free_list 中的下一个空闲进程，以形成链表（env_free_list 指向第一个空闲进程）。
3. **env_id**: 此成员唯一标识当前系统中正在运行的进程。当用户进程结束时，kernel 可能会将此进程的 Env 结构体分配给下一个运行的进程使用，但是他们的 env_id 成员是不一样的，即使用同一块内存，但是内存中的 **env_id** 域唯一的标识了这块内存。
4. **env_parent_id**: 记录此进程由哪个进程创建，形成 **"family tree"**。
5. **env_type**: 用来区别一些特殊的进程，目前只有 **ENV_TYPE_USER** 类型，定义在 **EnvType** 枚举类型里，在以后的实验中会向里面添加更多值。
6. **env_status**: 一共有 5 种类型：
    - **ENV_FREE**: Indicates that the Env structure is inactive, and therefore on the env_free_list.
    - **ENV_RUNNABLE**: Indicates that the Env structure represents an environment that is waiting to run on the processor.
    - **ENV_RUNNING**: Indicates that the Env structure represents the currently running environment.
    - **ENV_NOT_RUNNABLE**: Indicates that the Env structure represents a currently active environment, but it is not currently ready to run: for example, because it is waiting for an interprocess communication (IPC) from another environment.
    - **ENV_DYING**: Indicates that the Env structure represents a zombie environment. A zombie environment will be freed the next time it traps to the kernel. We will not use this flag until Lab 4.
7. **env_pgdir**: 这个变量保存着此进程的页目录的内核虚拟地址。

和 Unix 中的进程一样，JOS 的进程将线程和地址空间的概念结合到了一起：线程主要由 **env_tf** 成员描述；地址空间则由 **env_pgdir** 成员描述。为了运行一个进程，JOS kernel 必须为 CPU 设置好相关寄存器（Trapframe中的寄存器和控制寄存器）。

JOS 中的 **struct Env** 与 xv6 中的 **struct proc** 类似，两个结构体都在 **trapframe** 中都保存了用户态下的寄存器状态。与 xv6 不同的时，JOS 没有为每个进程单独设置内核栈，JOS 中任意时间只支持一个进程运行，所以 JOS 只需要一个单独的内核栈。关于这点可以对比一下两者的结构体：

```
struct proc {
  uint sz;                     // Size of process memory (bytes)
  pde_t* pgdir;                // Page table
  char *kstack;                // Bottom of kernel stack for this process(important)
  enum procstate state;        // Process state(important)
  int pid;                     // Process ID
  struct proc *parent;         // Parent process
  struct trapframe *tf;        // Trap frame for current syscall
  struct context *context;     // swtch() here to run process
  void *chan;                  // If non-zero, sleeping on chan
  int killed;                  // If non-zero, have been killed
  struct file *ofile[NOFILE];  // Open files
  struct inode *cwd;           // Current directory
  char name[16];               // Process name (debugging)
  // add for alarmtest.c
  int alarmticks;
  void (*alarmhandler)();
  int tick_counts;
};
```

可以看到，**struct proc** 比 **struct Env** 多了一个关键的成员 `char *kstack`，这就说明每创建一个进程就有一个 kstack 来记录此进程内核栈的位置，在 **xv6/proc.c/allocproc()** 中初始化内核栈：

```c
  if((p->kstack = kalloc()) == 0)
    p->state = UNUSED;
    return 0;
  }
```

### 2.2、Allocating the Environment Arrays

类似与 lab2，我们在 mem_init() 中分配一个 **Env** 结构体数组 **envs**，这个数组里包括 **NENV** 个结构体的实例， **envs** 这个全局变量在 kern/env.h 中声明，在 **kern/env.c** 中定义。

这个练习的主要目的就是为 **envs** 链表分配物理物理内存，再将这段内存映射到虚拟内存对应的位置：

```
                                                Permissions
                                                kernel/user
        4 Gig -> +------------------------------+
                 |                              | RW/--
                 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
                 :            ...               :
                 |~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~| RW/--
                 |                              | RW/--
                 |   Remapped Physical Memory   | RW/--
                 |                              | RW/--
    KERNBASE, -> +------------------------------+ 0xf0000000  -----------------+
    KSTACKTOP    |     CPU0's Kernel Stack      | RW/-- KSTKSIZE(8*PGSIZE)     |
                 | - - - - - - - - - - - - - - -|                              |
                 |      Invalid Memory (*)      | --/-- KSTKGAP(8*PGSIZE)      |
                 +------------------------------+                              |
                 |     CPU1's Kernel Stack      | RW/-- KSTKSIZE               |
                 | - - - - - - - - - - - - - - -|                         PTSIZE(1024*4096B
                 |      Invalid Memory (*)      | --/-- KSTKGAP                |
                 +------------------------------+                              |
                 :              .               :                              |
      MMIOLIM -> +------------------------------+ 0xefc00000  -----------------+
                 |       Memory-mapped I/O      | RW/--  PTSIZE
ULIM,MMIOBASE -> +------------------------------+ 0xef800000      
                 |  Cur. Page Table (User R-)   | R-/R-  PTSIZE    +-------+-----+-----+
         UVPT -> +------------------------------+ 0xef400000 ----> | 0x3BD | 0x0 | 0x0 |
                 |          RO PAGES            | R-/R-  PTSIZE    +-------+-----+-----+
       UPAGES -> +------------------------------+ 0xef000000
                 |           RO ENVS            | R-/R-  PTSIZE
   UTOP,UENVS -> +------------------------------+ 0xeec00000
```

映射到 [UENVS, UPAGES) 这段虚拟空间，下面看代码：

```
//////////////////////////////////////////////////////////////////////
// Make 'envs' point to an array of size 'NENV' of 'struct Env'.
// LAB 3: Your code here.

envs = (struct Env *)boot_alloc(NENV * sizeof(struct Env));
memset(envs, 0, NENV * sizeof(struct Env));
```

```
//////////////////////////////////////////////////////////////////////
// Map the 'envs' array read-only by the user at linear address UENVS
// (ie. perm = PTE_U | PTE_P).
// Permissions:
//    - the new image at UENVS  -- kernel R, user R
//    - envs itself -- kernel RW, user NONE
// LAB 3: Your code here.

boot_map_region(kern_pgdir, UENVS, PTSIZE, PADDR(envs), PTE_U | PTE_P);
```

关于执行后，**memset()** 函数将指针清空的问题，参照孟佬知乎[JOS 2018版本linker script问题
](https://zhuanlan.zhihu.com/p/46838542)。

### 2.3、Creating and Running Environments

接下来在 **kern/env.c** 中添加相关代码以支持进程的运行。因为现在 kernel 中没有文件系统，所以选择直接将二进制文件内嵌在 kernel 中。

JOS embeds this binary in the kernel as a ELF executable image.

此实验的 GNUmakefile 在 **obj/user/** 目录下生成了一些二进制文件。查看 **kern/Makefrag** 文件：

```
# Binary program images to embed within the kernel.
# Binary files for LAB3
KERN_BINFILES :=	user/hello \
			user/buggyhello \
			user/buggyhello2 \
			user/evilhello \
			user/testbss \
			user/divzero \
			user/breakpoint \
			user/softint \
			user/badsegment \
			user/faultread \
			user/faultreadkernel \
			user/faultwrite \
			user/faultwritekernel

KERN_OBJFILES := $(patsubst %.c, $(OBJDIR)/%.o, $(KERN_SRCFILES))
KERN_OBJFILES := $(patsubst %.S, $(OBJDIR)/%.o, $(KERN_OBJFILES))
KERN_OBJFILES := $(patsubst $(OBJDIR)/lib/%, $(OBJDIR)/kern/%, $(KERN_OBJFILES))
KERN_BINFILES := $(patsubst %, $(OBJDIR)/%, $(KERN_BINFILES))
```

The **-b binary** option on the linker command line causes these files to be linked in as "raw" uninterpreted binary files rather than as regular **.o** files produced by the compiler.(As far as the linker is concerned, these files do not have to be ELF images at all - they could be anything, such as text files or pictures!)

在 make 后，查看 **obj/kern/kernel.sym**，你会发现链接器产生了一些奇怪的符号：**_binary_obj_user_hello_start, _binary_obj_user_hello_end, _binary_obj_user_hello_size**。
通过这些符号去引用上面内嵌的二进制文件。

```
man ld
```

Exercise 2. In the file env.c, finish coding the following functions:

- **env_init()**: 在这个函数里面初始化之前分配的 **envs** 数组，并将它们添加进 **env_free_list** 链表，最后再调用 **env_init_percpu()**。
- **env_setup_vm()**: 为新建的进程创建页目录，然后初始化 kernel 部分的地址空间。
- **region_alloc()**: 为进程分配物理内存并完成映射。
- **load_icode()**: 将前面所提到的二进制文件加载进进程的地址空间。
- **env_create()**: 使用 env_alloc() 分配一个进程，并调用 load_icode() 将一个 ELF 文件加载进进程运行。
- **env_run()**: 指定一个进程在用户态下运行。

在完成这些函数的过程中，合理使用 **cprintf()** 的 **%e**，它会打印出错误码。

```c
r = -E_NO_MEM;
panic("env_alloc: %e", r);
```

打印结果："env_alloc: out of memory"。

下面是一些关键函数的调用顺序：

- start(kern/entry.S)
- i386_init(kern/init.c)
    - cons_init()
    - mem_init()
    - env_init()
    - trap_init()(still incomplete at this point)
    - env_create()
    - ent_run()
        - env_pop_tf()

我们按照这个顺序来完成函数。

#### 2.3.1、env_init()

> Mark all environments in 'envs' as free, set their env_ids to 0,
and insert them into the env_free_list.
Make sure the environments are in the free list in the same order
they are in the envs array (i.e., so that the first call to
env_alloc() returns envs[0]).

因为要求空闲链表元素的顺序与数组顺序相同，所以选择倒序插入。

```c
void
env_init(void)
{
	int i;
	env_free_list = NULL;
	for (i = NENV - 1; i >= 0; i--)
	{
		envs[i].env_id = 0;
		envs[i].env_link = env_free_list;
		env_free_list = &envs[i];
	}
	env_init_percpu();
}
```

#### 2.3.2、env_setup_vm()

> Initialize the kernel virtual memory layout for **environment e**.
Allocate a page directory, set e->env_pgdir accordingly,
and initialize the **kernel portion** of the new environment's address space.
**Do NOT** (yet) map anything into the user portion of the environment's virtual address space.

因为在 **pmap.c** 中已经写过了 kernel 的映射，所以直接将其复制过来即可，因为所有进程 kernel 部分的映射都是相同的。

```
static int
env_setup_vm(struct Env *e)
{
	int i;
	struct PageInfo *p = NULL;
	// Allocate a page for the page directory
	if (!(p = page_alloc(ALLOC_ZERO)))
		return -E_NO_MEM;
	// LAB 3: Your code here.
	p->pp_ref++;
	e->env_pgdir = (pde_t *)page2kva(p);
	memcpy(e->env_pgdir, kern_pgdir, PGSIZE);
	/*把页表映射到UVPT*/
	e->env_pgdir[PDX(UVPT)] = PADDR(e->env_pgdir) | PTE_P | PTE_U;
	return 0;
}
```

#### 2.3.3、region_alloc()

> Allocate **len** bytes of physical memory for environment **env**, and map it at virtual address va in the environment's address space. **Does not zero** or otherwise initialize the mapped pages in any way. Pages should be **writable** by user and kernel. **Panic** if any allocation attempt fails.

因为参数 va 和 len 有可能不是按页对齐的，所以对 va 做 Round Down 操作；对 va+len 做 Round Up 操作。注意一些极端情况。

上面也说了，不要对分配的物理内存做初始化工作，所以 **page_alloc()** 参数为 0。

```c
static void
region_alloc(struct Env *e, void *va, size_t len)
{
	void *begin_va = ROUNDDOWN(va, PGSIZE);
	void *end_va = ROUNDUP(va+len, PGSIZE);
	for (; begin_va < end_va; begin_va += PGSIZE)
	{
		struct PageInfo *pp = page_alloc(0);
		if (!pp) 
			panic("region_alloc() faild: pp == NULL");
		if (page_insert(e->env_pgdir, pp, begin_va, PTE_W | PTE_U) == -E_NO_MEM)
		 	panic("region_alloc() faild: page_inset() == -E_NO_MEM");
	}
}
```

#### 2.3.4、load_icode()

根据 ELF 段头表中的指示来加载各个段。并且只加载 ph->p_type 类型为 **ELF_PROG_LOAD** 的段。每个段的虚拟地址在 ph->p_va 里，大小在 ph->p_memsz 里。将 ELF 二进制文件中的 **[binary + ph->p_offset，binary + ph->p_offset + ph->p_filesz]** 大小的字节映射虚拟地址范围：**[ph->p_va, ph->p_va + ph->p_memsz]** 处。通常不会映射满（通常**ph->p_filesz <= ph->p_memsz**），空缺的字节一般是一些全局变量，将它们置为 0 即可。使用 lab 2 中的函数来完成分配和映射。这时 PTE 中的保护位应为 **PTE_U | PTE_W**。程序段一般没必要按页对齐。在这个函数里假设两个程序段不会使用到同一虚拟页。配合 region_alloc() 函数使用。

了解一下这个函数调用链：

```
+------------+
|ENV_CREATE()|
+------------+
      |
     \/
+------------+
|env_create()|
+------------+
      |
     \/
+------------+
|load_icode()|
+------------+
```

从这个调用链可知 **load_icode()** binary 参数来自 **kernel.sym** 中的型为 **_binary_obj_user_\*_start** 的符号。上面已经说过，因为现在还没有文件系统，为了完成本 lab 相关的测试，**obj/user/** 目录下的二进制文件已经在编译器就内嵌进了内核中。所以我们只需要照着 **kernel.sym** 引用其符号即可。

完成这个函数还需回顾一下 lab1 加载 kernel 的步骤（**boot/main.c**）。

```c
static void
load_icode(struct Env *e, uint8_t *binary)
{
	struct Proghdr *ph, *ph_end;
	struct Elf *ELFHDR = (struct Elf *)binary;
	if (ELFHDR->e_magic != ELF_MAGIC) panic("Not ELF!");
	ph = (struct Proghdr *)(ELFHDR->e_phoff + (uint8_t *)ELFHDR);
	ph_end = ph + ELFHDR->e_phnum;

	lcr3(PADDR(e->env_pgdir));

	for (; ph < ph_end; ph++){
		if (ph->p_type == ELF_PROG_LOAD)
		{
			region_alloc(e, (void *)ph->p_va, ph->p_memsz);
			memset((void *)ph->p_va, 0, ph->p_memsz);
			memcpy((void *)ph->p_va, binary + ph->p_offset, ph->p_filesz);
		}
	}

	lcr3(PADDR(kern_pgdir));
	e->env_tf.tf_eip = ELFHDR->e_entry;

	region_alloc(e, (void *)(USTACKTOP - PGSIZE), PGSIZE);
}
```

下面是 ELF 文件的相关信息：

```c
$ objdump -x hello

hello:     file format elf32-i386
hello
architecture: i386, flags 0x00000112:
EXEC_P, HAS_SYMS, D_PAGED
start address 0x00800020

Program Header:
   LOAD off    0x00001000 vaddr 0x00200000 paddr 0x00200000 align 2**12
        filesz 0x00004005 memsz 0x00004005 flags rw-
   LOAD off    0x00005020 vaddr 0x00800020 paddr 0x00800020 align 2**12
        filesz 0x00001140 memsz 0x00001140 flags r-x
   LOAD off    0x00007000 vaddr 0x00802000 paddr 0x00802000 align 2**12
        filesz 0x0000002c memsz 0x00000030 flags rw-
  STACK off    0x00000000 vaddr 0x00000000 paddr 0x00000000 align 2**4
        filesz 0x00000000 memsz 0x00000000 flags rwx
```

下面以加载 obj/usr/hello 二进制文件演示一下 for 循环里做了什么事：

```
Virtual Address Space
  +---------------+
  |               |   
  |     ...       |
  +---------------+ <- enf of kernel
  |               |
  |               |
  +---------------+
  |    hello      |
  +---------------+ <- 0xF011A330 (查看kernel.sym)
  |               |
  |     ...       |
  |               |
  +---------------+ <- 0xF0000000
  |     ...       |
  +---------------+
  | copied hello  |
  +---------------+ <- 0x00800020 (objdump可知)
  |     ...       |
  +---------------+
```

通过 **objdump -x hello** 得知，hello 这个可执行文件想要在想要在虚拟地址 0x00800020 处开始执行。然而，这个文件内嵌在 kenel ELF 中的虚拟地址却是 0xF011A330，二者不等。所以选择 **memcpy()** 函数，将 hello 文件拷贝到 0x00800020 处。可是直接拷贝还不行。因为通过浏览函数发现，此时硬件 MMU 使用的页目录是：

```c
void
mem_init(void)
{
  ...
  lcr3(PADDR(kern_pgdir));
  ...
}
```

这个页目录里只有内核的映射，如果在 memcpy() 中用到了用户空间的地址，就会 Page Fault（疑问TODO：page fault后为什么不能建立相应的PTE来弥补？）。在 for 循环里，我们通过 **region_alloc()** 函数逐步的建立此进程用户空间的映射。所以在 for 循环前，使用：

```
lcr3(PADDR(e->env_pgdir));
```

将页目录切换到当前进程的页目录，for 循环结束后再切换回去。

#### 2.3.5、env_create()

> Allocates a new env with env_alloc, loads the named elf binary into it with load_icode, and sets its env_type. This function is ONLY called during kernel initialization, before running the first user-mode environment. The new env's parent ID is set to 0.

```c
void
env_create(uint8_t *binary, enum EnvType type)
{
	struct Env *new_env = NULL;
	if (env_alloc(&new_env, 0) < 0)
		panic("env_alloc() failed!");
	load_icode(new_env, binary);
	new_env->env_type = type;
}
```

#### 2.3.5、env_run()

> Context switch from **curenv** to env **e**. Note: if this is the first call to **env_run()**, curenv is **NULL**.

```c
void
env_run(struct Env *e)
{
	if (curenv != NULL)
	{
		if (curenv->env_status == ENV_RUNNING)
			curenv->env_status = ENV_RUNNABLE;
	}
	curenv = e;
	curenv->env_status = ENV_RUNNING;
	curenv->env_runs++;
	lcr3(PADDR(curenv->env_pgdir));
	env_pop_tf(&(curenv->env_tf));
}
```

当完成这些函数后，编译内核并启动 QEMU，打印如下：

```c
[00000000] new env 00001000
entry 800020EAX=00000000 EBX=00000000 ECX=0000000d EDX=eebfde88
ESI=00000000 EDI=00000000 EBP=eebfde60 ESP=eebfde54
EIP=00800bc3 EFL=00000092 [--S-A--] CPL=3 II=0 A20=1 SMM=0 HLT=0
ES =0023 00000000 ffffffff 00cff300 DPL=3 DS   [-WA]
CS =001b 00000000 ffffffff 00cffa00 DPL=3 CS32 [-R-]
SS =0023 00000000 ffffffff 00cff300 DPL=3 DS   [-WA]
DS =0023 00000000 ffffffff 00cff300 DPL=3 DS   [-WA]
FS =0023 00000000 ffffffff 00cff300 DPL=3 DS   [-WA]
GS =0023 00000000 ffffffff 00cff300 DPL=3 DS   [-WA]
LDT=0000 00000000 00000000 00008200 DPL=0 LDT
TR =0028 f0182b80 00000067 00408900 DPL=0 TSS32-avl
GDT=     f011b300 0000002f
IDT=     f0182360 000007ff
CR0=80050033 CR2=00000000 CR3=003bc000 CR4=00000000
DR0=00000000 DR1=00000000 DR2=00000000 DR3=00000000 
DR6=ffff0ff0 DR7=00000400
EFER=0000000000000000
Triple fault.  Halting for inspection via QEMU monitor.
```

根据 **EIP=00800bc3** 查找 **hello.asm**：

```
  800bbd:	89 c3                	mov    %eax,%ebx
  800bbf:	89 c7                	mov    %eax,%edi
  800bc1:	89 c6                	mov    %eax,%esi
  800bc3:	cd 30                	int    $0x30
	syscall(SYS_cputs, 0, (uint32_t)s, len, 0, 0, 0);
}
  800bc5:	5b                   	pop    %ebx
```

看来报错是正常的，因为目前 JOS 还不支持完整的中断和异常处理。

### 2.4、Handing Interrupts and Exceptions

在 JOS 中实现异常和系统调用处理。这样内核才能从用户态中接过控制权。

阅读材料：

- [Chapter 9: Exceptions and Interrupts](https://pdos.csail.mit.edu/6.828/2018/readings/i386/c09.htm)
- [IA-32 Develop's Manual: Chapter 5](https://pdos.csail.mit.edu/6.828/2018/readings/ia32/IA32-3A.pdf)

这里推荐阅读 Intel 的手册。

### 2.5、Basic of Protected Control Transfer

> Exceptions and interrupts are both "protected control transfers," which cause the processor to switch from user to kernel mode (CPL=0) without giving the user-mode code any opportunity to interfere with the functioning of the kernel or other environments.

在 x86 中，当系统发生异常或者处理器接收到中断后，转去执行相应的 handler，执行哪个 handler 不由用户程序决定，而是通过以下两个机制来决定：

- The Interrupt Descriptor Table([IDT](https://en.wikipedia.org/wiki/Interrupt_descriptor_table))
- The Task State Segment([TSS](https://en.wikipedia.org/wiki/Task_state_segment))

在 IDT 中，指定了 256 个进入 kernel 的入口点，它们对应着不同的中断或异常。IDT 的内容是由 kernel 编程。

大多时候，执行 handler 后还需要回到用户态， 继续执行被打断的用户程序。这就需要在进入内核态前，保存下当时的处理器状态。在 JOS 中，我们将这些状态保存在进程的内核栈里，内核栈的位置由 TSS.SSO 和 TSS.ESP0 指定。

### 2.6、Type of Exceptions and Interrupts

异常通常对应 IDT 0~31 的范围，剩下的 32~255 范围则通常对应软中断（INT n）和硬中断（external device）。

### 2.7、Example

假设一个在用户态下的程序执行了除以 0 的操作（处理器内部异常）。

- 通过查询 TSS.SS0 和 TSS.ESP0，切换到内核栈。在 JOS 中，TSS.SS0=GD_KD，TSS.ESP0=KSTACKTOP。
- 将处理器状态（寄存器）压内核栈。
+-------------+ <- KSTACKTOP
| 0x00 |old SS|
+-------------+
|   old ESP   |
+-------------+
|  old EFLAGS |
+-------------+
| 0x00 |old CS|
+-------------+
|   old EIP   |
+-------------+ <- ESP = KSTACKTOP-20
- 除法错误在 x86 中对应 IDT entry 0，结合 entry 0 和 GDT，读取 CS:EIP（指向handler）。
- 
























&nbsp;

## 三、Part B: Page Faults，Breakpoints Exceptions and System Calls

___
