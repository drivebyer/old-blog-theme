---
layout: post
title: "MIT6.828 操作系统 HW: Locks"
comments: true
description: "MIT6.828 操作系统 HW: Locks"
keywords: "OS, assembly, c"
---


## Interrupts in ide.c

这个作业问为什么 xv6 在 acquire() 一开始取消当前处理器的中断，而在 release() 最后设置中断，并以 **ide.c** 中两个函数为例。

先按照作业要求在 **iderw()** 中添加 `sti()` 和 `cli()`:

```c
void
iderw(struct buf *b)
{
  struct buf **pp;
  if(!holdingsleep(&b->lock))
    panic("iderw: buf not locked");
  if((b->flags & (B_VALID|B_DIRTY)) == B_VALID)
    panic("iderw: nothing to do");
  if(b->dev != 0 && !havedisk1)
    panic("iderw: ide disk 1 not present");
  acquire(&idelock);
  sti();
  b->qnext = 0;
  for(pp=&idequeue; *pp; pp=&(*pp)->qnext)
    ;
  *pp = b;

  if(idequeue == b)
    idestart(b);

  while((b->flags & (B_VALID|B_DIRTY)) != B_VALID){
    sleep(b, &idelock);
  }
  cli();
  release(&idelock);
}
```

假设在执行 `b->qnext = 0` 的时候，处理器接受到了一个磁盘中断。于是处理器暂停 **iderw()**，通过层层调用，最终到达 Interrupt Handler:

```c
void
ideintr(void)
{
  struct buf *b;
  acquire(&idelock);

  if((b = idequeue) == 0){
    release(&idelock);
    return;
  }
  idequeue = b->qnext;
  if(!(b->flags & B_DIRTY) && idewait(1) >= 0)
    insl(0x1f0, b->data, BSIZE/4);

  b->flags |= B_VALID;
  b->flags &= ~B_DIRTY;
  wakeup(b);
  if(idequeue != 0)
    idestart(idequeue);

  release(&idelock);
}
```

这时问题出现了，当处理器进入 `acquire(&idelock)`:

```c
void
acquire(struct spinlock *lk)
{
  pushcli();
  if(holding(lk))
    panic("acquire");

  while(xchg(&lk->locked, 1) != 0)
    ;

  __sync_synchronize();

  lk->cpu = mycpu();
  getcallerpcs(&lk, lk->pcs);
}
```

执行 `holding(lk)`，结果为真，因为这个处理器从 `iderw()` 过来，一直持有 **idelock** 这把锁，这时内核就 panic 了。
