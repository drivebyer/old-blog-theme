---
layout: post
title: "MIT6.828 操作系统 HW: Uthreads"
comments: true
description: "MIT6.828 操作系统 HW: Uthreads"
keywords: "OS, assembly, c"
---

&nbsp;

## 一、Switching threads

___

这个作业要求在 xv6 中实现用户级线程，并实现线程间的上下文切换。

首先在 xv6 中添加两个文件: [uthread.c](https://pdos.csail.mit.edu/6.828/2018/homework/uthread.c) 和 [uthread_switch.S](https://pdos.csail.mit.edu/6.828/2018/homework/uthread_switch.S)。再在 xv6/Makefile 中 _forktest rule 后面添加:

```
_uthread: uthread.o uthread_switch.o
	$(LD) $(LDFLAGS) -N -e main -Ttext 0 -o _uthread uthread.o uthread_switch.o $(ULIB)
	$(OBJDUMP) -S _uthread > uthread.asm
```

最后在 UPROGS 中添加 _uthread\。这时启动 xv6 会报错 Page Fault（trapno=14）：

```
wu@wu-insparition:~/6.828/xv6/xv6-public$ make CPUS=1 qemu-nox
qemu-system-i386 -nographic -drive file=fs.img,index=1,media=disk,format=raw -drive file=xv6.img,index=0,media=disk,format=raw -smp 1 -m 512 
xv6...
cpu0: starting 0
sb: size 1000 nblocks 941 ninodes 200 nlog 30 logstart 2 inodestart 32 bmap start 58
init: starting sh
$ uthread
pid 4 uthread: trap 14 err 5 on cpu 0 eip 0xffffffff addr 0xffffffff--kill proc
```

这时需要我们深入理解上面提供的代码。实现用户级线程（以后简称线程）的关键就是下面这个数据结构：

```
struct thread {
  int        sp;                /* saved stack pointer */
  char stack[STACK_SIZE];       /* the thread's stack */
  int        state;             /* FREE, RUNNING, RUNNABLE */
};
```

线程需要维护自己的栈区（内存区域）和线程状态，并且手动维护栈指针来管理栈。这里要注意主线程栈区和我们实现的线程栈区的区别，下面是它俩在虚拟地址空间中的位置关系：

```
+------------+
|   kernel   |
+------------+
|  run-time  |
|   stack    | <-+ main thread
+-----+------+
|     |      |
|     v      |
|            |
|     ^      |
|     |      |
+-----+------+
|            |
|    heap    |
|            |
+------------+
|    .bss    | <-+ user-level thread
+------------+
|   .data    |
+------------+
|  read-only |
|    code    |
|   segment  |
+------------+
|  unused    |
+------------+
```

首先是 **thread_init()** 函数：

```c
void 
thread_init(void)
{
  current_thread = &all_thread[0];
  current_thread->state = RUNNING;
}
```

这个函数将主线程（main）当做数组 **all_thread[]** 中第一个元素来管理，然后调用两次 **thread_create()** 函数：

```c
void 
thread_create(void (*func)())
{
  thread_p t;
  for (t = all_thread; t < all_thread + MAX_THREAD; t++) {
    if (t->state == FREE) break;
  }
  t->sp = (int) (t->stack + STACK_SIZE);   // set sp to the top of the stack
  t->sp -= 4;                              // space for return address
  *(int *) (t->sp) = (int)func;            // push return address on stack
  t->sp -= 32;                             // space for registers that thread_switch expects
  t->state = RUNNABLE;
}
```

这个函数寻找数组 **all_thread[]** 中线程状态为 FREE 的空槽，对其初始化，如果将 **.bss** 放大（暂时忽略结构体中为了对齐而产生的空隙）：

```
              .bss
         +-------------+
         |     ...     |
  +----> +-------------+
  |      |    state    | 
  |      +-------------+
  |      |    func     |
  |      +-------------+ <--------+
  |      |   thread    |          |
  |      |   switch    |    32 Bytes(8 registers)
  |      |  registers  |          |
  |      +-------------+ <-+ sp +-+
Thread 2 |             |
  |      |    .....    |
  |      |             |
  |      +-------------+
  |      |     sp      |
  +----> +-------------+
  |      |    state    | RUNNABLE
  |      +-------------+
  |      |    func     |
  |      +-------------+ <--------+
  |      |   thread    |          |
  |      |   switch    |    32 Bytes(8 registers)
  |      |  registers  |          |
  |      +-------------+ <-+ sp +-+
Thread 1 |             |
  |      |    .....    |
  |      |             |
  |      +-------------+
  |      |     sp      |
  +----> +-------------+
  |      |    state    | RUNNING
  |      +-------------+
  |      |     ...     |
Thread 0 |    stack    |
  |      |     ...     |
  |      +-------------+
  |      |     sp      |
  +----> +-------------+
         |     ...     |
         +-------------+
```

然后执行 **thread_schedule()** 函数：

```
static void 
thread_schedule(void)
{
  thread_p t;
  next_thread = 0;
  for (t = all_thread; t < all_thread + MAX_THREAD; t++) {
    if (t->state == RUNNABLE && t != current_thread) {
      next_thread = t;
      break;
    }
  }
  if (t >= all_thread + MAX_THREAD && current_thread->state == RUNNABLE) {
    next_thread = current_thread;
  }
  if (next_thread == 0) {
    printf(2, "thread_schedule: no runnable threads\n");
    exit();
  }
  if (current_thread != next_thread) {
    next_thread->state = RUNNING;
    thread_switch();
  } else
    next_thread = 0;
}
```

**thread_schedule()** 函数在线程数组中顺序找到一个 RUNNABLE 的线程，然后执行 **thread_switch** 汇编开始线程的上下文切换。下面是完成后的 **thread_switch**：

```

```
