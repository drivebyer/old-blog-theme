---
layout: post
title: "MIT6.828 操作系统 Lab4: Preemptive Multitasking"
comments: true
description: "MIT6.828 操作系统 Lab4: Preemptive Multitasking"
keywords: "OS, assembly, c"
---

&nbsp;

## 一、Introduction

___

Part A 的任务是使 JOS 支持多处理器，并且添加 [Round-Robin](https://en.wikipedia.org/wiki/Round-robin_scheduling) 调度。并实现几个系统调用，如创建进程和销毁进程，分配和映射内存等。

Part B 要求实现一个类 Unix 的 fork() 函数。

Part C 则要求在 JOS 中支持进程间通信（[IPC](https://en.wikipedia.org/wiki/Inter-process_communication)）。

在远程主机上拉取 lab4 的内容，并合并。下面是本实验中一些重要的源文件：

- **kern/cpu.h**:	    Kernel-private definitions for multiprocessor support
- **kern/mpconfig.c**:	Code to read the multiprocessor configuration
- **kern/lapic.c**:	    Kernel code driving the local APIC unit in each processor
- **kern/mpentry.S**:	Assembly-language entry code for non-boot CPUs
- **kern/spinlock.h**:	Kernel-private definitions for spin locks, including the big kernel lock
- **kern/spinlock.c**:	Kernel code implementing spin locks
- **kern/sched.c**:	    Code skeleton of the scheduler that you are about to implement

&nbsp;

## 二、Part A: Multiprocessor Support and Cooperative Multitasking

___

本部分的三个任务：

- Multiprocessor Support
- Round-Robin Scheduling
- System Calls for Environment Creation

### 2.1、Multiprocessor Support

JOS 中支持的是 [SMP](https://en.wikipedia.org/wiki/Symmetric_multiprocessing)（Symmetric Multiprocessing）。在 SMP 架构中，处理器分为两类：

- bootstrap processor(BSP)
- application processors(APs)

BSP 是启动时使用的处理器，它主要负责初始化系统和操作系统，初始化完成后在激活其他的 APs。多处理器架构中，哪个处理器是 BSP，是由硬件和 BIOS 决定的。

在 SMP 系统中，每个 CPU 都有一个 Local APIC（LAPIC）。LAPIC 负责传递中断到处理器：

![APIC](http://ww1.sinaimg.cn/large/c9caade4gy1g43xwowyxjj20mt08qdk6.jpg)

> The **LAPIC** also provides its connected CPU with a unique identifier.

在本实验中，我们可以利用 lapic 来获取一些有用的信息：

- Reading the LAPIC identifier (APIC ID) to tell which CPU our code is currently running on (see cpunum()).
- Sending the STARTUP interprocessor interrupt (IPI) from the BSP to the APs to bring up other CPUs (see lapic_startap()).
- In part C, we program LAPIC's built-in timer to trigger clock interrupts to support preemptive multitasking (see apic_init()).

处理器读写 lapic 使用的是 [Memory-mapped I/O](https://en.wikipedia.org/wiki/Memory-mapped_I/O)（MMIO）。简单来说 MMIO 就是将一段内存单元（4MB）硬连线到外设的寄存器上，这样就能使用 load/store 指令读写外设。

这段内存单元在物理内存上是固定的，我们将这段内存映射到 JOS 指定的虚拟地址空间上：

```
                                                 Virtual Memory
                                              +-------------------+
            Physical Memory                   |                   |
       4GB +----------------+                 |                   |
           |       .        |                 |                   |
           |       .        |                 |        .          |
           |       .        |                 |        .          |
           +----------------+                 |        .          |
           |      4MB       +-----+           |                   |
0xFE000000 +----------------+     |           |                   |
           |                |     |           |                   |
           |                |     |           |                   |
           |                |     |           |                   |
           |       .        |     |           |                   |
           |       .        |     |  MMIOLIM  +-------------------+ 0xefc00000
           |       .        |     +---------> | Memory|mapped I/O | RW/--  PTSIZE
           |                |        MMIOBASE +-------------------+ 0xef800000
           |                |                 |                   |
           |                |                 |        .          |
           |                |                 |        .          |
           |                |                 |        .          |
           |                |                 |                   |
           |                |                 |                   |
           +----------------+                 +-------------------+
```

#### 2.1.1、Exercise 1

> Implement **mmio_map_region()** in kern/pmap.c. To see how this is used, look at the beginning of lapic_init in kern/lapic.c. You'll have to do the next exercise, too, before the tests for mmio_map_region will run.

下面来完成这部分的映射。

```c
void *
mmio_map_region(physaddr_t pa, size_t size)
{
	static uintptr_t base = MMIOBASE;
	if (base + size > MMIOLIM)
		panic("MMIO map overflow!");
	physaddr_t pa_begin = (physaddr_t)ROUNDDOWN(pa, PGSIZE);
	physaddr_t pa_end = (physaddr_t)ROUNDUP(pa+size, PGSIZE);
	boot_map_region(kern_pgdir, 
	                base, 
					pa_end - pa_begin, 
					pa_begin, 
					PTE_PCD | PTE_PWT | PTE_W);
	return (void *)base;
}
```

这段内存区域与其他区域不同，CPU 不能缓存这部分内容，所以我们在 PTE 标志位设为 **PTE_PCD()|PTE_PWT|PTE_W**：

- PTE_PCD: disable cached
- PTE_PWT: write through

#### 2.1.2、Application Processors Bootstrap

在启动其他处理器之前，系统应该先收集这些处理器的信息，例如：

- CPU的数量
- APIC ID
- LAPIC 单元的 MMIO 地址



### 2.2、Round-Robin Scheduling

### 2.3、System Calls for Environment Creation





















&nbsp;

## 三、Part B: Copy-on-Write Fork

___

&nbsp;

## 四、Part C: Preemptive Multitasking and Inter-Process communication(IPC)

___