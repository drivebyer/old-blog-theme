---
layout: post
title: "xv6: 文件系统(二)"
comments: true
description: "xv6: 文件系统(二)"
keywords: "OS, xv6, c, file system"
---

&nbsp;

## 一、介绍

___

这篇文章纪录下我学习 xv6 文件系统（以后简称xv6fs）的过程，先导篇: [xv6: 文件系统(一)](https://wuyang.me/2019/xv6-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F(%E4%B8%80)/)。

xv6fs 算是整个 xv6 源码中的重头戏，整个文件系统很抽象，对于我这种 Unix 小白，头一次阅读这种代码十分的懵。经过反复阅读，终于领悟到了一点其中的奥妙。

下面是 xv6fs 逻辑上的分层图：

```
+------------------+
|  File Descriptor |
+------------------+
|     Pathname     |
+------------------+
|     Directory    |
+------------------+
|      Inode       |
+------------------+
|     Logging      |
+------------------+
|   Buffer Cache   |
+------------------+
|       Disk       |
+------------------+
```

下面从下向上依次介绍。

&nbsp;

## 二、Disk

___

xv6 中磁盘驱动主要由 [ide.c](https://github.com/mit-pdos/xv6-public/blob/master/ide.c) 文件实现。这个文件下有以下变量和函数:

```c
static struct spinlock idelock;
static struct buf *idequeue;
static int havedisk1;

static int idewait(int checkerr);
static void idestart(struct buf *b);
void iderw(struct buf *b);
void ideintr(void);
void ideinit(void);
```

其中暴露给 buffer cache 层的是函数 **iderw()**。此函数发起对磁盘的读写 **idestart()**。因为磁盘操作很耗时，随即进入睡眠状态:

```c
void
iderw(struct buf *b)
{
  ...
  if(idequeue == b)
    idestart(b);
  while((b->flags & (B_VALID|B_DIRTY)) != B_VALID){
    sleep(b, &idelock);
  }
  ...
}
```

等到磁盘的读写完成后，会收到一个来自磁盘控制器的中断 **T_IRQ0 + IRQ_IDE**，然后进入 **ideintr()** 函数:

```
void
ideintr(void)
{
  ...
  if(!(b->flags & B_DIRTY) && idewait(1) >= 0)
    insl(0x1f0, b->data, BSIZE/4);

  b->flags |= B_VALID;
  b->flags &= ~B_DIRTY;
  wakeup(b);

  if(idequeue != 0)
    idestart(idequeue);
  ...
}
```

处理来自磁盘的中断，对应队列中第一个buffer，要么是磁盘控制器上有新的数据，需要读取，要么是告诉 OS 之前的写操作已经完成，这取决于前面 iderw()-> idestart() 执行的写操作还是读操作。执行完 `wakeup(b)` 后，唤醒在 **iderw()** 中睡眠的进程，整个 buffer 的操作结束。

通过中断的方式，可以让等待磁盘操作的进程睡眠，让出处理器。这是一种比较有效的方式。可是这个进程还是会阻塞在 **iderw()** 函数。 

&nbsp;

## 三、Buffer Cache

___

这一层唯一操作的数据结构是:

```c
struct {
  struct spinlock lock;
  struct buf buf[NBUF];

  struct buf head;
} bcache;


```

首先 buffer cache 通过 **binit()** 函数初始化:

```c
void
binit(void)
{
  struct buf *b;

  initlock(&bcache.lock, "bcache");

  bcache.head.prev = &bcache.head;
  bcache.head.next = &bcache.head;
  for(b = bcache.buf; b < bcache.buf+NBUF; b++){
    b->next = bcache.head.next;
    b->prev = &bcache.head;
    initsleeplock(&b->lock, "buffer");
    bcache.head.next->prev = b;
    bcache.head.next = b;
  }
}
```

它将 bcache.buf 初始化成一个双向链表，这个双向链表实现了 LRU 算法，只需知道 bcache.head 是最常使用的 buffer。

这一层暴露给 log 层的函数有三个:

```c
struct buf* bread(uint dev, uint blockno);
void bwrite(struct buf *b);
void brelse(struct buf *b);
```

首先看 **bread()** 函数:

```c
struct buf*
bread(uint dev, uint blockno)
{
  struct buf *b;
  b = bget(dev, blockno);
  if((b->flags & B_VALID) == 0) {
    iderw(b);
  }
  return b;
}
```

这个函数实现的关键在于 **bget()**:

```c
static struct buf* bget(uint dev, uint blockno)
{
  struct buf *b;
  acquire(&bcache.lock);
  for(b = bcache.head.next; b != &bcache.head; b = b->next){
    if(b->dev == dev && b->blockno == blockno){
      b->refcnt++;
      release(&bcache.lock);
      acquiresleep(&b->lock);
      return b;
    }
  }
  for(b = bcache.head.prev; b != &bcache.head; b = b->prev){
    if(b->refcnt == 0 && (b->flags & B_DIRTY) == 0) {
      b->dev = dev;
      b->blockno = blockno;
      b->flags = 0;
      b->refcnt = 1;
      release(&bcache.lock);
      acquiresleep(&b->lock);
      return b;
    }
  }
  panic("bget: no buffers");
}
```

这个函数遍历 bcache.buf 双向链表，先从 bcache.head 起，正向查找链表(这里利用了程序的局部性原理)。看能不能找到指定参数的 block 的缓存(第一个for循环)。如果找不到，再反向查找链表(第二个for循环)，找到一个b->refcnt为0，且数据与磁盘同步 buffer，将这个 buffer 设置为新的参数，并返回。注意返回之前要对 buffer 加锁

当我们使用 bread() 拿到某个 block 的 buffer 后，有可能对其数据进行修改。修改完后，调用 bwrite() 将 buffer 中的修改写回到磁盘，最后调用 brealse()，表明对 buffer 的操作已经结束。

通常对这一层的接口有下面两种形式的调用:

```
+-------+      +--------+
| bread +----->+ brelse |
+-------+      +--------+

+-------+      +--------+     +--------+     +--------+
| bread +----->+ update +---->+ bwrite +---->+ brelse |
+-------+      +--------+     +--------+     +--------+
```

注意，获取锁的操作都隐藏在了 bread() 与 brelse() 中。调用 brelse() 后就不能再对同一个 buffer 进行操作了。

&nbsp;

## 四、Log

___

在 log 层，两个重要的结构是:

```c
struct logheader {
  int n;
  int block[LOGSIZE];
};

struct log {
  struct spinlock lock;
  int start;
  int size;
  int outstanding;
  int committing;
  int dev;
  struct logheader lh;
};
struct log log;
```

该层暴露在外的接口有:

```c
void begin_op(void);
void log_write(struct buf *b);
void end_op(void);
void initlog(int dev);
```

在 xv6 中，一个文件操作大致是如下顺序:

```c
begin_op(); 
...
bp1 = bread(); 
bp1->data[] = ...; 
log_write(bp1); 
brelse(bp1);
...
end_op()
```

首先使用 begin_op():

```c
void
begin_op(void)
{
  acquire(&log.lock);
  while(1){
      ...
      log.outstanding += 1;
      ...
    }
  }
}
```

说明即将开始对文件进行操作，在 log 区为预留一块区域(log.outstanding += 1)存放 log。然后开始对 buffer 进行修改。与 buffer cache 层概念不同的是，这里不会立刻调用 bwrite() 将修改写回磁盘快(这样就达不到log的目的了)，而是使用了 **log_write()**:

```c
void
log_write(struct buf *b)
{
  ...
  log.lh.block[i] = b->blockno;
  ...
}
```

在 logheader 中记录下对哪些 block 进行了修改。然后调用 **end_op()**，这个函数经过一系列的判断后，最终执行 **commit()**:

```c
static void commit()
{
  if (log.lh.n > 0) {
    write_log();    
    write_head();   
    install_trans();
    log.lh.n = 0;
    write_head();   
  }
}
```

调用 write_log():

```c
static void write_log(void)
{
  int tail;
  for (tail = 0; tail < log.lh.n; tail++) {
    struct buf *to = bread(log.dev, log.start+tail+1);
    struct buf *from = bread(log.dev, log.lh.block[tail]);
    memmove(to->data, from->data, BSIZE);
    bwrite(to);  // write the log
    brelse(from);
    brelse(to);
  }
}
```

先将所有的修改存放到 log 区(紧跟着logheader)。然后调用 write_head():

```c
static void write_head(void)
{
  struct buf *buf = bread(log.dev, log.start);
  struct logheader *hb = (struct logheader *) (buf->data);
  int i;
  hb->n = log.lh.n;
  for (i = 0; i < log.lh.n; i++) {
    hb->block[i] = log.lh.block[i];
  }
  bwrite(buf);
  brelse(buf);
}
```

将之前记录的修改过的 block 号存进磁盘上的 **logheader.block[]** 中。接着调用 install_trans:

```c
static void install_trans(void)
{
  int tail;
  for (tail = 0; tail < log.lh.n; tail++) {
    struct buf *lbuf = bread(log.dev, log.start+tail+1); 
    struct buf *dbuf = bread(log.dev, log.lh.block[tail]);
    memmove(dbuf->data, lbuf->data, BSIZE);
    bwrite(dbuf);  // write dst to disk
    brelse(lbuf);
    brelse(dbuf);
  }
}
```

最终将 log 中暂存的修改写入它们在磁盘上原本的地方。最后执行:

```c
log.lh.n = 0;
write_head();
```

将 log 标记为空。整个过程类似于:

![](http://ww1.sinaimg.cn/large/c9caade4gy1g48173sr7wj21640ecq45.jpg)

&nbsp;

## 五、Inode

___

这一层是比较复杂的，其中有两个关键的结构:

```
struct inode {
  uint dev;           // Device number
  uint inum;          // Inode number
  int ref;            /*表明有多少个 C 指针指向这个inode，只有这个数不为零时，
                       *inode才存在于内存中，iget()和iput()修改它
                       *这个指针来自 file descriptor，current working directory，或者exec()函数
                       */
  struct sleeplock lock; // protects everything below here
  int valid;          // inode has been read from disk?
  
  // copy of disk inode
  short type;         // File type  dinode free:0   T_DIR:1   T_FILE:2   T_DEV:3
  short major;
  short minor;
  short nlink;        /*表明有多少个 directory entry 链接到 inode，当这个数为 0 时，type也等于0*/
  uint size;
  uint addrs[NDIRECT+1];
};
```

```
// On-disk inode structure
struct dinode {
  short type;           // File type  dinode free:0   T_DIR:1   T_FILE:2   T_DEV:3
  short major;          // Major device number (T_DEV only)
  short minor;          // Minor device number (T_DEV only)
  short nlink;          /*表明有多少个 directory entry 链接到 inode，当这个数为 0 时，type也等于0*/
  uint size;            /*inode所表示文件字节数*/
  uint addrs[NDIRECT+1];   /*表明inode表示的文件内容都在哪些block中*/
};
```

这两个结构部分内容是相同的，dinode 被拷贝到内存存放在 inode 中。

inode 描述了一个文件，这个文件的内容通过 dinode.addrs[] 描述，它们指向 data block，其余的成员则描述了文件的元数据:

![](http://ww1.sinaimg.cn/large/c9caade4ly1g49rt6jltaj218q0xkwkz.jpg)

inodes 顺序的分布在磁盘上，起始位置为 superblock.startinode。与普通的 data block 一样，OS 将一些常用的 inode 存放在内存:

```c
struct {
  struct spinlock lock;
  struct inode inode[NINODE];
} icache;
```

因为存在多个进程使用同一个 inode 的情况，所以 in-memory inode 的另一个作用是同步。下面来看一下 fs.c(文件系统) 中对外的接口:

```c
// inode
void iinit(int dev);
struct inode* ialloc(uint dev, short type);
void iupdate(struct inode *ip);
static struct inode* iget(uint dev, uint inum);
struct inode* idup(struct inode *ip);
void ilock(struct inode *ip);
void iunlock(struct inode *ip);
void iput(struct inode *ip);
void iunlockput(struct inode *ip);

//inode-content
static uint bmap(struct inode *ip, uint bn);
static void itrunc(struct inode *ip);
void stati(struct inode *ip, struct stat *st);
int readi(struct inode *ip, char *dst, uint off, uint n);
int writei(struct inode *ip, char *src, uint off, uint n);

// directory
int namecmp(const char *s, const char *t);
struct inode* dirlookup(struct inode *dp, char *name, uint *poff);
int dirlink(struct inode *dp, char *name, uint inum);

// path
static char* skipelem(char *path, char *name);
static struct inode* namex(char *path, int nameiparent, char *name);
struct inode* namei(char *path);
struct inode* nameiparent(char *path, char *name);

```