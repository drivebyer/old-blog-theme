---
layout: post
title: "xv6: 文件系统(二)"
comments: true
description: "xv6: 文件系统(二)"
keywords: "OS, xv6, c, file system"
---

&nbsp;

## 一、介绍

___

这篇文章纪录下我学习 xv6 文件系统（以后简称xv6fs）的过程，先导篇: [xv6: 文件系统(一)](https://wuyang.me/2019/xv6-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F(%E4%B8%80)/)。

xv6fs 算是整个 xv6 源码中的重头戏，整个文件系统很抽象，对于我这种 Unix 小白，头一次阅读这种代码十分的懵。经过反复阅读，终于领悟到了一点其中的奥妙。

下面是 xv6fs 逻辑上的分层图：

```
+------------------+
|  File Descriptor |
+------------------+
|     Pathname     |
+------------------+
|     Directory    |
+------------------+
|      Inode       |
+------------------+
|     Logging      |
+------------------+
|   Buffer Cache   |
+------------------+
|       Disk       |
+------------------+
```

下面从下向上依次介绍。

&nbsp;

## 二、Disk

___

xv6 中磁盘驱动主要由 [ide.c](https://github.com/mit-pdos/xv6-public/blob/master/ide.c) 文件实现。这个文件下有以下变量和函数:

```c
static struct spinlock idelock;
static struct buf *idequeue;
static int havedisk1;

static int idewait(int checkerr);
static void idestart(struct buf *b);
void iderw(struct buf *b);
void ideintr(void);
void ideinit(void);
```

其中暴露给 buffer cache 层的是函数 **iderw()**。此函数发起对磁盘的读写 **idestart()**。因为磁盘操作很耗时，随即进入睡眠状态:

```c
void
iderw(struct buf *b)
{
  ...
  if(idequeue == b)
    idestart(b);
  while((b->flags & (B_VALID|B_DIRTY)) != B_VALID){
    sleep(b, &idelock);
  }
  ...
}
```

等到磁盘的读写完成后，会收到一个来自磁盘控制器的中断 **T_IRQ0 + IRQ_IDE**，然后进入 **ideintr()** 函数:

```
void
ideintr(void)
{
  ...
  if(!(b->flags & B_DIRTY) && idewait(1) >= 0)
    insl(0x1f0, b->data, BSIZE/4);

  b->flags |= B_VALID;
  b->flags &= ~B_DIRTY;
  wakeup(b);

  if(idequeue != 0)
    idestart(idequeue);
  ...
}
```

处理来自磁盘的中断，对应队列中第一个buffer，要么是磁盘控制器上有新的数据，需要读取，要么是告诉 OS 之前的写操作已经完成，这取决于前面 iderw()-> idestart() 执行的写操作还是读操作。执行完 `wakeup(b)` 后，唤醒在 **iderw()** 中睡眠的进程，整个 buffer 的操作结束。

通过中断的方式，可以让等待磁盘操作的进程睡眠，让出处理器。这是一种比较有效的方式。可是这个进程还是会阻塞在 **iderw()** 函数。 

&nbsp;

## 三、Buffer Cache

___

这一层唯一操作的数据结构是:

```c
struct {
  struct spinlock lock;
  struct buf buf[NBUF];

  struct buf head;
} bcache;


```

首先 buffer cache 通过 **binit()** 函数初始化:

```c
void
binit(void)
{
  struct buf *b;

  initlock(&bcache.lock, "bcache");

  bcache.head.prev = &bcache.head;
  bcache.head.next = &bcache.head;
  for(b = bcache.buf; b < bcache.buf+NBUF; b++){
    b->next = bcache.head.next;
    b->prev = &bcache.head;
    initsleeplock(&b->lock, "buffer");
    bcache.head.next->prev = b;
    bcache.head.next = b;
  }
}
```

它将 bcache.buf 初始化成一个双向链表，这个双向链表实现了 LRU 算法，只需知道 bcache.head 是最常使用的 buffer。

这一层暴露给 log 层的函数有三个:

```c
struct buf* bread(uint dev, uint blockno);
void bwrite(struct buf *b);
void brelse(struct buf *b);
```

首先看 **bread()** 函数:

```c
struct buf*
bread(uint dev, uint blockno)
{
  struct buf *b;
  b = bget(dev, blockno);
  if((b->flags & B_VALID) == 0) {
    iderw(b);
  }
  return b;
}
```

这个函数实现的关键在于 **bget()**:

```c
static struct buf* bget(uint dev, uint blockno)
{
  struct buf *b;
  acquire(&bcache.lock);
  for(b = bcache.head.next; b != &bcache.head; b = b->next){
    if(b->dev == dev && b->blockno == blockno){
      b->refcnt++;
      release(&bcache.lock);
      acquiresleep(&b->lock);
      return b;
    }
  }
  for(b = bcache.head.prev; b != &bcache.head; b = b->prev){
    if(b->refcnt == 0 && (b->flags & B_DIRTY) == 0) {
      b->dev = dev;
      b->blockno = blockno;
      b->flags = 0;
      b->refcnt = 1;
      release(&bcache.lock);
      acquiresleep(&b->lock);
      return b;
    }
  }
  panic("bget: no buffers");
}
```

这个函数遍历 bcache.buf 双向链表，先从 bcache.head 起，正向查找链表(这里利用了程序的局部性原理)。看能不能找到指定参数的 block 的缓存(第一个for循环)。如果找不到，再反向查找链表(第二个for循环)，找到一个b->refcnt为0，且数据与磁盘同步 buffer，将这个 buffer 设置为新的参数，并返回。注意返回之前要对 buffer 加锁

当我们使用 bread() 拿到某个 block 的 buffer 后，有可能对其数据进行修改。修改完后，调用 bwrite() 将 buffer 中的修改写回到磁盘，最后调用 brealse()，表明对 buffer 的操作已经结束。

通常对这一层的接口有下面两种形式的调用:

```
+-------+      +--------+
| bread +----->+ brelse |
+-------+      +--------+

+-------+      +--------+     +--------+     +--------+
| bread +----->+ update +---->+ bwrite +---->+ brelse |
+-------+      +--------+     +--------+     +--------+
```

注意，获取锁的操作都隐藏在了 bread() 与 brelse() 中。调用 brelse() 后就不能再对同一个 buffer 进行操作了。

&nbsp;

## 四、Log

___

在 log 层，两个重要的结构是:

```c
struct logheader {
  int n;
  int block[LOGSIZE];
};

struct log {
  struct spinlock lock;
  int start;
  int size;
  int outstanding;
  int committing;
  int dev;
  struct logheader lh;
};
struct log log;
```

该层暴露在外的接口有:

```c
void begin_op(void);
void log_write(struct buf *b);
void end_op(void);
void initlog(int dev);
```

在 xv6 中，一个文件操作大致是如下顺序:

```c
begin_op(); 
...
bp1 = bread(); 
bp1->data[] = ...; 
log_write(bp1); 
brelse(bp1);

bp2 = bread();
bp2->data[] = ...; 
log_write(bp2);
brelse(bp); 
...
end_op()
```

首先使用 begin_op():

```c
void
begin_op(void)
{
  acquire(&log.lock);
  while(1){
      ...
      log.outstanding += 1;
      ...
    }
  }
}
```

说明即将开始对文件进行操作，在 log 区为预留一块区域存放 log。


其中内部函数有:

```c
static void write_log(void);
static void write_head(void);
static void install_trans(void);
static void commit();
static void recover_from_log(void);
static void read_head(void);
```

先看其中一个重要的函数:

```c
static void commit()
{
  if (log.lh.n > 0) {
    write_log();
    write_head();
    install_trans();
    log.lh.n = 0;
    write_head(); 
  }
}
```





xv6文件系统由inode组成，每个inode是单个未命名的文件

UNIX file systems assign one inode to each file in the file system,a file's inode holds critical meta-data about the file such as its stat attributes and pointers to its data blocks.

Be wary of the distinction between the two terms: sector size is a property of the disk hardware, whereas block size is an aspect of the operating system using the disk. A file system's block size must be a multiple of the sector size of the underlying disk.

File systems typically reserve certain disk blocks at "easy-to-find" locations on the disk (such as the very start or the very end) to hold meta-data describing properties of the file system as a whole, such as the block size, disk size, any meta-data required to find the root directory, the time the file system was last mounted, the time the file system was last checked for errors, and so on. These special blocks are called superblocks.