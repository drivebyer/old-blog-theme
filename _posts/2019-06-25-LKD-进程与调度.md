---
layout: post
title: "《linux内核设计与实现》阅读笔记-进程与调度"
comments: true
description: "《linux内核设计与实现》阅读笔记-进程与调度"
keywords: "OS, LKD, schedule"
---

&nbsp;

## 一、进程

___

process:

- executing program code(text section)
- data section containing global variables
- open files 
- pending signals
- internal kernel data
- address space
- one or more threads of execution

> Processes, in effect, are the living result of running program code.

这是 LKD 对进程的经典描述。

### 1.1、进程描述符

进程描述符(Process Descriptor)在 linux 中就是指 [`struct task_struct`](https://elixir.bootlin.com/linux/v2.6.38/source/include/linux/sched.h#L1193) 结构体，这个结构体在 32 位机器上大约是 1.7KB。

#### 1.1.1、PID

```c
struct task_struct {
    ...
    pit_t pid;
    ...
}
```

#### 1.1.2、current 宏

linux 通常获取一个指向 task_struct 的指针，通过指针直接操作进程。针对不同体系结构实现了 current 宏。例如在 x86 下:

```c
DECLARE_PER_CPU(struct task_struct *, current_task);

#define current get_current()

static __always_inline struct task_struct *get_current(void)
{
	return percpu_read_stable(current_task);
}

#define percpu_read_stable(var)		percpu_from_op("mov", var, "p" (&(var)))
```

32bit 64bit 机器上的指针大小分别是 4B 和 8B，故截取部分:

```c
#define percpu_from_op(op, var, constraint)		\
({							\
	typeof(var) pfo_ret__;				\
	switch (sizeof(var)) {				\
    ...
	case 4:						\
		asm(op "l "__percpu_arg(1)",%0"		\
		    : "=r" (pfo_ret__)			\
		    : constraint);			\
		break;					\
	case 8:						\
		asm(op "q "__percpu_arg(1)",%0"		\
		    : "=r" (pfo_ret__)			\
		    : constraint);			\
		break;					\
	default: __bad_percpu_size();			\
	}						\
	pfo_ret__;					\
})
```

```c
#define __percpu_arg(x)		"%%"__stringify(__percpu_seg)":%P" #x    %%

#ifdef CONFIG_X86_64
#define __percpu_seg		gs
#define __percpu_mov_op		movq
#else
#define __percpu_seg		fs
#define __percpu_mov_op		movl
#endif
```

```c
asm(movl "%%fs:%P1","%0" : 
    "=r" (pfo_ret__) :
    "p" (&(var))

asm(movq "%%gs:%P1", "%0" : 
    "=r" (pfo_ret__) :
    "p" (&(var))
```

这段汇编将段寄存器 fs:P1 gs:P2 处的内容读出来(参考:[linux内核数据结构](https://www.cnblogs.com/LittleHann/p/3865490.html))，那这个位置的内容到底是什么呢？(TODO)

上一个宏在 /arch/x86/include/asm 中；另外在源码 **/include/asm-generic** 中还通用宏定义:

```c
#define get_current() (current_thread_info()->task)
#define current get_current()
```

```c
static inline struct thread_info *current_thread_info(void)
{
	struct thread_info *ti;
	ti = (void *)(percpu_read_stable(kernel_stack) +
		      KERNEL_STACK_OFFSET - THREAD_SIZE);
	return ti;
}
```

![](http://ww1.sinaimg.cn/large/c9caade4gy1g4euv02cvuj21000lcabo.jpg)

### 1.2、进程状态

```c
#define TASK_RUNNING		0
#define TASK_INTERRUPTIBLE	1
#define TASK_UNINTERRUPTIBLE	2
#define __TASK_STOPPED		4
#define __TASK_TRACED		8
```

```c
struct task_struct {
    ...
	volatile long state;
    ...
}
```

```c
set_current_state(state);
set_task_state(current, state);
```

### 1.3、进程的经历

```
+----------+       +----------+      +----------+
|          |       |          |      |          |
|  fork()  +------>+  exec()  +----->+  exit()  |
|          |       |          |      |          |
+----------+       +----+-----+      +----+-----+
                        |                 |
                        |                 |
                        |                 v
                        |            +----+-----+
                        |            |          |
                        +----------->+  wait()  +--------->
                                     |          |
                                     +----------+
```

#### 1.3.1 进程创建(CoW fork)

Copy-on-Write(CoW) 中译写时拷贝。在 CoW fork() 后，父子进程所有数据都只有一份，即它们映射到的物理内存是相同的。它们的 PTE 标志都是 read-only，一旦父进程或者子进程对共享区域执行了写操作，所以就会触发 Page Fault。系统发现 Page Fault 是因为写 CoW 区域造成。系统将写操作区域复制一份，然后将触发这个操作的进程的 PTE 指向新复制内存(并设置PTE为Write)。重新执行写操作，这时候复制的区域的写操作成功。

linux 实现了 CoW fork。

#### 1.3.2 进程终结















linux 的调度单位是线程，而不是进程。对于 linux 来说，线程是一种特殊的进程。

Interestingly, note that threads share the virtual memory abstraction, whereas each receives its own virtualized processor.因为线程共享父进程的地址空间，但是它们又被linux当作进程同等调度。之所以能这么做，我猜测是因为 linux 中的调度管理资源的方法很极致，以至于线程再多也关系不大。

In contemporary Linux kernels, fork() is actually implemented via the clone() system call






在 linux 中，将线程和进程同等对待(同等调度)。线程由进程 fork 而来，



&nbsp;

## 二、进程调度

___

参考资料:

- [Linux Scheduler](https://oakbytes.wordpress.com/linux-scheduler/)
- [Linux内核调度分析（进程调度）](https://juejin.im/post/5a97c9025188255579180e43)
- [linux内核数据结构](https://www.cnblogs.com/LittleHann/p/3865490.html)