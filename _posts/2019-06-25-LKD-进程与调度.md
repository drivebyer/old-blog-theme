---
layout: post
title: "《linux内核设计与实现》阅读笔记-进程与调度"
comments: true
description: "《linux内核设计与实现》阅读笔记-进程与调度"
keywords: "OS, LKD, schedule"
---

&nbsp;

## 一、进程

___

process:

- executing program code(text section)
- data section containing global variables
- open files 
- pending signals
- internal kernel data
- address space
- one or more threads of execution

> Processes, in effect, are the living result of running program code.

这是 LKD 对进程的经典描述。

### 1.1、进程描述符

进程描述符(Process Descriptor)在 linux 中就是指 [`struct task_struct`](https://elixir.bootlin.com/linux/v2.6.38/source/include/linux/sched.h#L1193) 结构体，这个结构体在 32 位机器上大约是 1.7KB。

#### 1.1.1、PID

```c
struct task_struct {
    ...
    pit_t pid;
    ...
}
```

#### 1.1.2、current 宏

linux 通常获取一个指向 task_struct 的指针，通过指针直接操作进程。针对不同体系结构实现了 current 宏。例如在 x86 下:

```
     +---------+
     | current |
     +----+----+
          |
          v
    +-----+---------+
    | get_current() |
    +-----+---------+
          |
          v
+---------+------------+
| percpu_read_stable() |
+---------+------------+
          |
          v
  +-------+----------+
  | percpu_from_op() |
  +------------------+
```

```c
#define __percpu_arg(x)		"%%"__stringify(__percpu_seg)":%P" #x    %%

#ifdef CONFIG_X86_64
#define __percpu_seg		gs
#define __percpu_mov_op		movq
#else
#define __percpu_seg		fs
#define __percpu_mov_op		movl
#endif
```

```c
asm(movl "%%fs:%P1","%0" : 
    "=r" (pfo_ret__) :
    "p" (&(var))

asm(movq "%%gs:%P1", "%0" : 
    "=r" (pfo_ret__) :
    "p" (&(var))
```

这段汇编将段寄存器 fs:P1 gs:P2 处的内容读出来(参考:[linux内核数据结构](https://www.cnblogs.com/LittleHann/p/3865490.html))，那这个位置的内容到底是什么呢？(TODO)

上一个宏在 /arch/x86/include/asm 中；另外在源码 **/include/asm-generic** 中还通用宏定义:

```
       +---------+
       | current |
       +----+----+
            |
            v
    +-------+-------+
    | get_current() |
    +-------+-------+
            |
            v
+-----------+-----------+
| current_thread_info() |
+-----------+-----------+
            |
            v
 +----------+-----------+
 | percpu_read_stable() |
 +----------------------+
```

![](http://ww1.sinaimg.cn/large/c9caade4gy1g4euv02cvuj21000lcabo.jpg)

### 1.2、进程状态

```
#define TASK_RUNNING		0
#define TASK_INTERRUPTIBLE	1
#define TASK_UNINTERRUPTIBLE	2
#define __TASK_STOPPED		4
#define __TASK_TRACED		8
```

```c
struct task_struct {
    ...
	volatile long state;
    ...
}
```

```c
set_current_state(state);
set_task_state(current, state);
```

### 1.3、进程的经历

```
+----------+       +----------+      +----------+
|  fork()  +------>+  exec()  +----->+  exit()  |
+----------+       +----+-----+      +----+-----+
                        |                 |
                        |                 v
                        |            +----+-----+
                        +----------->+  wait()  +--------->
                                     +----------+
```

#### 1.3.1 进程创建(CoW fork)

Copy-on-Write(CoW) 中译写时拷贝。在 CoW fork() 后，父子进程所有数据都只有一份，即它们映射到的物理内存是相同的。它们的 PTE 标志都是 read-only，一旦父进程或者子进程对共享区域执行了写操作，所以就会触发 Page Fault。系统发现 Page Fault 是因为写 CoW 区域造成。系统将写操作区域复制一份，然后将触发这个操作的进程的 PTE 指向新复制内存(并设置PTE为Write)。重新执行写操作，这时候复制的区域的写操作成功。

linux 实现了 CoW fork。

```
+------------+     +-------------+     +-------------+     +-----------------+
| sys_fork() |     | sys_vfork() |     | sys_clone() |     | kernel_thread() |
+------+-----+     +-------------+     +----+--------+     +-------+---------+
       |               |                    |                      |
       |               +------+  +----------+                      |
       |                      |  |                                 |
       +-------------------+  |  |  +------------------------------+
                           |  |  |  |
                          +v--v--v--v--+
                          |  do_fork() |
                          +------+-----+
                                 |
                         +-------+--------+
                         | copy_process() |
                         +----+---+-------+
      +--------------------+  |   |  |------------------------------+
      |                       |   +---------------+                 |
      v                       v                   v                 v
 +----+--------+      +-------+---------+     +---+----------+    +-+---+
 | alloc_pid() |      |dup_task_struct()|     | copy_flags() |    | ... |
 +-------------+      +-----------------+     +--------------+    +-----+
```

子进程共享 or 复制父进程的资源，取决于 flags 参数:

```
#define CSIGNAL		    0x000000ff	/* signal mask to be sent at exit */
#define CLONE_VM	    0x00000100	/* set if VM shared between processes */
#define CLONE_FS	    0x00000200	/* set if fs info shared between processes */
#define CLONE_FILES	    0x00000400	/* set if open files shared between processes */
#define CLONE_SIGHAND	0x00000800	/* set if signal handlers and blocked signals shared */
...
#define CLONE_NEWNET	0x40000000	/* New network namespace */
#define CLONE_IO		0x80000000	/* Clone io context */
```

fork 成功后，linux 通常让子进程先运行。原因如下:

假设，父子进程返回用户空间后，调度父进程先运行。父进程可能执行一个写操作，这时会触发 CoW。如果调度让子进程先运行，子进程在 fork 后通常会执行 exec。就不和父进程共享数据了，后面即是父进程再执行写操作，也不会触发 CoW。

对于 linux 来说，线程(Thread)是一种特殊的进程。创建的是线程还是进程，取决于 fork 时的 flag 参数:

```
// 线程
clone(CLONE_VM | CLONE_FS | CLONE_FILES | CLONE_SIGHAND, 0);
```

```
// 进程
clone(SIGCHLD, 0);
```




#### 1.3.2 进程终结















linux 的调度单位是线程，而不是进程。对于 linux 来说，线程是一种特殊的进程。

Interestingly, note that threads share the virtual memory abstraction, whereas each receives its own virtualized processor.因为线程共享父进程的地址空间，但是它们又被linux当作进程同等调度。之所以能这么做，我猜测是因为 linux 中的调度管理资源的方法很极致，以至于线程再多也关系不大。

In contemporary Linux kernels, fork() is actually implemented via the clone() system call






在 linux 中，将线程和进程同等对待(同等调度)。线程由进程 fork 而来，



&nbsp;

## 二、进程调度

___

参考资料:

- [Linux Scheduler](https://oakbytes.wordpress.com/linux-scheduler/)
- [Linux内核调度分析（进程调度）](https://juejin.im/post/5a97c9025188255579180e43)
- [linux内核数据结构](https://www.cnblogs.com/LittleHann/p/3865490.html)