---
layout: post
title: "Go 语言中的闭包"
comments: true
description: "Go 语言中的闭包"
keywords: "Go, 闭包"
---

最近刚开始学习 Go，在看 GoPL 第五章的时候，接触到了闭包这个概念。在书中，闭包出现在匿名函数一节里，说明二者联系紧密。

在这一章里，举了这个例子:

```
func squares() func() int { 
    var x int 
    return func() int { 
        x++ 
        return x * x 
    } 
} 
func main() { 
    f := squares() 
    fmt.Println(f()) // "1" 
    fmt.Println(f()) // "4" 
    fmt.Println(f()) // "9" 
    fmt.Println(f()) // "16" 
}
```

看到这个代码，第一感觉是 squares() 函数的本地变量 x 发生了逃逸，后来通过命令行:

```
go run -gcflags '-m -l' main.go
```

证实 x 确实逃逸了。这个例子首先证明了一点，变量的 lifetime 与 scope 是不同的概念。只这一点还不足以说明什么。上面例子中关键语句是 `f := squares()`。将 main 函数改为:

```
func main() { 
    f := squares() 
    fmt.Println(f()) // "1"
    fmt.Println(f()) // "4"

    g := squares()  
    fmt.Println(g()) // "1" 
    fmt.Println(g()) // "4" 
}
```

GoPL 对这个现象的解释如下:

> The function squares returns another function, of type **func() int**. A call to squares creates a local variable x and returns an anonymous function that, each time it is called, increments x and returns its square . A second call to squares would create a second variable x and return a new anonymous function which increments that variable.

每次调用 squares() 都会创建一个 scope 属于 squares() 的本地变量。在闭包 f 和 g 中，可以理解为各自持有这个变量的指针(参考[Go 语言闭包详解](https://juejin.im/post/5c850d035188257ec629e73e))。通过 f() g() 调用匿名函数，这时会去堆中(解引用)找各自的 x 值。



向 main 中添加两行代码:

```
fmt.Printf("%v %T", f, f)
fmt.Printf("%v %T", g, g)
```

输出为:

```
0x489d30 func() int
0x489d30 func() int
```

这是一个低地址，通过 **objdump -h main** 查看一下 .text section 的范围:

```
Sections:
Idx name    Size        VMA     ....
0   .text   00088ebb    0000000000401000
```

可见，f g 都指向同一个代码段位置。唯一不同的是，它们在执行时拥有各自对堆上数据的引用。连续调用一个闭包匿名函数，会有一个 keep state 的效果，因为它们是操作的同一份数据。

参考资料:

- [The Go Program Language](https://book.douban.com/subject/26337545/)
- [What is a Closure?](https://www.calhoun.io/what-is-a-closure/)
- [Go 语言闭包详解](https://juejin.im/post/5c850d035188257ec629e73e)
