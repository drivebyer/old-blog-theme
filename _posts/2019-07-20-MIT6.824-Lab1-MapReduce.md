---
layout: post
title: "MIT6.824 分布式系统 Lab1: MapReduce"
comments: true
description: "MIT6.824 分布式系统 Lab1: MapReduce"
keywords: "分布式, Go"
---

[6.824 Lab 1: MapReduce](https://pdos.csail.mit.edu/6.824/labs/lab-1.html)

&nbsp;

### 一、Part One

___

这两个函数主要做 User-Define function 与 MapReduce 库之间的衔接作用。在将 immediate K/V 写入中间文件时，应该是整个文件内容是一个 JSON 对象，而不是每个 K/V 一个 JSON 对象。由于对 Go 中 JSON 对象的操作不是很熟，这里还费了不少时间。

```go
func doMap(
	jobName string, // the name of the MapReduce job
	mapTask int, // which map task this is
	inFile string,
	nReduce int, // the number of reduce task that will be run ("R" in the paper)
	mapF func(filename string, contents string) []KeyValue,
) {
	// 读取文件内容
	content, err := ioutil.ReadFile(inFile)
    if err != nil {
        panic(err)
    }
	// 传入 user-defined function，获得 immediate k/v
	kvs := mapF(inFile, string(content))
    tasks := make([][]KeyValue, nReduce)
    for _, kv := range kvs {
		// 根据 nReduce 个数 hash 分类
        num := ihash(kv.Key) % nReduce
        tasks[num] = append(tasks[num], kv)
    }
    for i, task := range tasks {
        filename := reduceName(jobName, mapTask, i)
        file, err := os.Create(filename)
        defer file.Close()
        if err != nil {
            panic(err)
		}
		// 一次性将一个 map task 下的一次中间 kv 存入中间文件
        kvsJson, err := json.Marshal(task)
        if err != nil {
            panic(err)
        }
        if _, err := file.Write(kvsJson); err != nil {
            panic(err)
        }
    }
}
```

```go
func doReduce(
	jobName string, // the name of the whole MapReduce job
	reduceTask int, // which reduce task this is
	outFile string, // write the output here
	nMap int, // the number of map tasks that were run ("M" in the paper)
	reduceF func(key string, values []string) string,
) {
	kvs := make([]KeyValue, 0)
	for i := 0; i < nMap; i++ {
		imFileName := reduceName(jobName, i, reduceTask)
		content, err := ioutil.ReadFile(imFileName)
		if err != nil {
			panic(err)
		}
		kv := make([]KeyValue, 0)
		if err := json.Unmarshal(content, &kv); err != nil {
			panic(err)
		}	
		for _, v := range kv {
			kvs = append(kvs, v)
		}
	}
	kvMap := make(map[string][]string)
	for _, v := range kvs {
		kvMap[v.Key] = append(kvMap[v.Key], v.Value)
	}
	outFilePtr, err := os.Create(outFile)
	if err != nil {
		panic(err)
	}
	enc := json.NewEncoder(outFilePtr)
	for k, v := range kvMap {
		enc.Encode(KeyValue{k, reduceF(k, v)})
	}
	if err := outFilePtr.Close(); err != nil {
		panic(err)
	}
}
```

