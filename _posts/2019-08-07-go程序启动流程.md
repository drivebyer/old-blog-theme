---
layout: post
title: "Go程序启动流程"
comments: true
description: "Go程序启动流程"
keywords: "Go"
---

测试环境：
```
$ go version
go version go1.12.7 linux/amd64
$ uname -a
Linux wu-insparition 4.18.0-25-generic #26~18.04.1-Ubuntu SMP Thu Jun 27 07:28:31 UTC 2019 x86_64 x86_64 x86_64 GNU/Linux
```

测试范例：
```
package main
import "fmt"
func main() {
	fmt.Println("hello,world")
}
```

程序的入口处为：

```go
// usr/local/go/src/runtime/rt0_linux_amd64.s
TEXT _rt0_amd64_linux(SB),NOSPLIT,$-8
	JMP	_rt0_amd64(SB)
```

将断点打在`_rt0_amd64`处：

```go
TEXT _rt0_amd64(SB),NOSPLIT,$-8
	MOVQ	0(SP), DI	// argc
	LEAQ	8(SP), SI	// argv
	JMP	runtime·rt0_go(SB)
```

由于我们将断点打在用户空间的入口处，在这之前在内核中涉及到进程的`do_fork()`，这里的argc和argv应该与这个函数的参数有关，由于不影响整个流程，这里分析暂先跳过。下面执行到`rt0_go`：

```go
TEXT runtime·rt0_go(SB),NOSPLIT,$0
	MOVQ	DI, AX		// argc
	MOVQ	SI, BX		// argv
	SUBQ	$(4*8+7), SP		// 2args 2auto
	ANDQ	$~15, SP
	MOVQ	AX, 16(SP)
	MOVQ	BX, 24(SP)
```
这里做了一下参数的拷贝，栈的变化大致如下：
```
+---------+
|         |
|         |
+---------+ <--+ 0x00007fffdafd5120
|         |
|         |
|         |
|         |
|         |
|         |
|         |
+---------+ <--+ 0x00007fffdafd50f9
|         |
|         |
+---------+ <--+ 0x00007fffdafd50f0 sp
|         |
|         |
|         |
|         |
|         |
|         |
|         |
|         |
|         |
+---------+
```

```go
MOVQ	$runtime·g0(SB), DI    // 这里将全局的g0放进DI
LEAQ	(-64*1024+104)(SP), BX
MOVQ	BX, g_stackguard0(DI)
MOVQ	BX, g_stackguard1(DI)  // 设置g0的stackguard0和stackguard1
MOVQ	BX, (g_stack+stack_lo)(DI)
MOVQ	SP, (g_stack+stack_hi)(DI) // 设置g0的stack.hi和stack.lo
```

可以看出g0的栈大约为64K（system stack）。省略一些读取CPU与cgo的代码，接着看：

```
LEAQ	runtime·m0+m_tls(SB), DI // 将m0.tls的地址放进DI
CALL	runtime·settls(SB)
```
```go
TEXT runtime·settls(SB),NOSPLIT,$32
	...
	ADDQ	$8, DI	// ELF wants to use -8(FS)，这里暂时没明白为什么会这样设计TODO
	...
	MOVQ	DI, SI  // 将m0.tls的地址作为系统调用的参数之一
	MOVQ	$0x1002, DI	// ARCH_SET_FS
	MOVQ	$SYS_arch_prctl, AX // 存入系统调用号
	SYSCALL
	CMPQ	AX, $0xfffffffffffff001 // 是否成功
	JLS	2(PC) // 如果成功直接调到RET处返回
	MOVL	$0xf1, 0xf1  // crash
	RET
```

这里涉及到TLS的相关知识。总的来说做了两件事：（1）告诉kernel，用户空间以后会用FS这个段寄存器来访问TLS段（glibc使用了GS段寄存器）。（2）告诉kernel，当前线程的TSL是m0.tls。

```go
get_tls(BX)
MOVQ	$0x123, g(BX)
MOVQ	runtime·m0+m_tls(SB), AX
CMPQ	AX, $0x123
JEQ 2(PC)
CALL	runtime·abort(SB)
```
这段代码是为了测试m0的TLS是否设置成功。通过查看m0.tls[0]处的值，发现0x123确实以十进制数291的形式存入了。这里令我疑惑的是代码中的一个宏：
```c
#define g(r)    0(r)(TLS*1) 
```
从表面上，没看出这个宏的作用。通过向`get_tls(BX)`后添加一句`MOVQ	g(BX), AX`，查看rax寄存器中的值居然是0。但是不影响进行，有空再深究TODO。

```go
ok:
	// set the per-goroutine and per-mach "registers"
	get_tls(BX)
	LEAQ	runtime·g0(SB), CX  
	MOVQ	CX, g(BX) // 将g0的地址放进当前线程（m0）的TLS
	LEAQ	runtime·m0(SB), AX

	// save m->g0 = g0
	MOVQ	CX, m_g0(AX)
	// save m0 to g0->m
	MOVQ	AX, g_m(CX)

	CLD				// convention is D is always left cleared
	CALL	runtime·check(SB)
```

```
(dlv) p m0.tls
[6]uintptr [5746784,0,0,0,0,0]
(dlv) p &g0
(*runtime.g)(0x57b060)
```
可以看到g0的地址以十进制的形式存入了m0.tls。

```
MOVL	16(SP), AX		// copy argc
MOVL	AX, 0(SP)
MOVQ	24(SP), AX		// copy argv
MOVQ	AX, 8(SP)
```
这里拷贝参数到esp的正上方（注意中间有ret addr），这两个参数分别是下面3个初始化函数的参数：
```go
CALL	runtime·args(SB)
CALL	runtime·osinit(SB)  // 获取core个数，本机上为4
CALL	runtime·schedinit(SB)
```
```go
func schedinit() {
	// 这是一个特殊的函数，它的函数体由编译器填写
	// 这个函数的返回值有3种可能：
	// 1. m.g0
	// 2. m.gsinnal
	// 3. m.curg
	// 更多见HACKING.md
	_g_ := getg()  // 这里返回的是当前m的g0，即全局的g0
	if raceenabled {
		_g_.racectx, raceprocctx0 = raceinit()
	}

	sched.maxmcount = 10000  // 最大m数量

	tracebackinit() // skipPC=4546432
	moduledataverify() // symbol table
	stackinit()  // 初始化栈池
	mallocinit()  // 内存初始化，留着看allocator的时候再来分析TODO
	mcommoninit(_g_.m)
	cpuinit()       // must run before alginit
	alginit()       // maps must not be used before this call
	modulesinit()   // provides activeModules
	typelinksinit() // uses maps, activeModules
	itabsinit()     // uses activeModules

	msigsave(_g_.m)
	initSigmask = _g_.m.sigmask

	// 这里将g0栈上的两个fork参数拷贝到此程序的全局变量中
	goargs()
	goenvs()
	
	parsedebugvars()
	gcinit() // gc相关的初始化TODO

	sched.lastpoll = uint64(nanotime())
	procs := ncpu
	if n, ok := atoi32(gogetenv("GOMAXPROCS")); ok && n > 0 {
		procs = n
	}
	// 初始化procs个p，并将当前m与第一个p建立联系
	if procresize(procs) != nil {
		throw("unknown runnable goroutine during bootstrap")
	}

	// For cgocheck > 1, we turn on the write barrier at all times
	// and check all pointer writes. We can't do this until after
	// procresize because the write barrier needs a P.
	if debug.cgocheck > 1 {
		writeBarrier.cgo = true
		writeBarrier.enabled = true
		for _, p := range allp {
			p.wbBuf.reset()
		}
	}

	if buildVersion == "" {
		// Condition should never trigger. This code just serves
		// to ensure runtime·buildVersion is kept in the resulting binary.
		buildVersion = "unknown"
	}
}
```

```go
// create a new goroutine to start program
MOVQ	$runtime·mainPC(SB), AX		// entry
PUSHQ	AX
PUSHQ	$0			// arg size
CALL	runtime·newproc(SB)
POPQ	AX
POPQ	AX
```
注意这里mainPC是：
```go
DATA	runtime·mainPC+0(SB)/8,$runtime·main(SB)
```
下面进入newproc函数：
```
func newproc(siz int32, fn *funcval) {
	argp := add(unsafe.Pointer(&fn), sys.PtrSize) // argp
	gp := getg()
	pc := getcallerpc()
	systemstack(func() {
		newproc1(fn, (*uint8)(argp), siz, gp, pc)
	})
}
```

```
// start this M
CALL	runtime·mstart(SB)

CALL	runtime·abort(SB)	// mstart should never return
RET

// Prevent dead-code elimination of debugCallV1, which is
// intended to be called by debuggers.
MOVQ	$runtime·debugCallV1(SB), AX
RET
```




