---
layout: post
title: '探索m的一生'
subtitle: '如何得到m'
date: 2019-08-13
categories: 技术
cover: ''
tags: Golang
---

环境：
```go
$ go version
go version go1.12.7 linux/amd64
$ uname -a
Linux wu-insparition 4.18.0-25-generic #26~18.04.1-Ubuntu SMP Thu Jun 27 07:28:31 UTC 2019 x86_64 x86_64 x86_64 GNU/Linux
```

go调度的实现还是挺复杂的，从最简单的m切入再好不过了。

## 如何得到m
___
### 创建一个全新的m
m是一个结构体，在runtime中分配一个m通常使用new关键字`new(m)`。整个runtime中唯一调用`new(m)`的地方，就是allocm函数：
```go
// Allocate a new m unassociated with any thread.
// Can use p for allocation context if needed.
// fn is recorded as the new m's m.mstartfn.
//
// This function is allowed to have write barriers even if the caller
// isn't because it borrows _p_.
//
//go:yeswritebarrierrec
func allocm(_p_ *p, fn func()) *m {
    // 通过tls得到当前线程正在运行的g
    // g还是g0，还不确定TODO
    // 但是看到获取_g_的目的都是在使用_g_.m（当前线程），所以无论是g还是g0，_g_.m结果都一样
	_g_ := getg() 
	_g_.m.locks++ // disable GC because it can be called from sysmon
	if _g_.m.p == 0 {
        // 如果当前线程没有p，就把为allocm函数准备的_p_
        // 暂时借给当前线程_g_.m
		acquirep(_p_) // temporarily borrow p for mallocs in this function
	}

	// Release the free M list. We need to do this somewhere and
	// this may free up a stack we can use.
	if sched.freem != nil {
		lock(&sched.lock)
		var newList *m
		for freem := sched.freem; freem != nil; {
			if freem.freeWait != 0 {
				next := freem.freelink
				freem.freelink = newList
				newList = freem
				freem = next
				continue
            }
            // 正如freeWait的注释所说
            // if == 0, safe to free g0 and delete m (atomic)
            // 释放sched.freem中sched.freem.freeWait=0的m的系统栈（g0）
			stackfree(freem.g0.stack)
			freem = freem.freelink
		}
		sched.freem = newList
		unlock(&sched.lock)
	}

	mp := new(m) // 在堆上分配一个m
    mp.mstartfn = fn 
    // （1）给mp分配信号栈gsignal
    // （2）将mp链入全局allm
	mcommoninit(mp)

	// In case of cgo or Solaris or Darwin, pthread_create will make us a stack.
    // Windows and Plan 9 will layout sched stack on OS stack.
    // 正如注释所说，如果是下面几种系统，g0栈通过创建线程分配
	if iscgo || GOOS == "solaris" || GOOS == "windows" || GOOS == "plan9" || GOOS == "darwin" {
		mp.g0 = malg(-1)
	} else {
		mp.g0 = malg(8192 * sys.StackGuardMultiplier) // 分配g0，栈大小为8K
	}
	mp.g0.m = mp

	if _p_ == _g_.m.p.ptr() {
		releasep() // 这里与前面的acquirep(_p_)相呼应。
	}
	_g_.m.locks--
	if _g_.m.locks == 0 && _g_.preempt { // restore the preemption request in case we've cleared it in newstack
		_g_.stackguard0 = stackPreempt // TODO
    }
    
	return mp
}
```
注意这个函数的注释：创建一个没有与thread相关联的m，为什么？因为在allocm函数里，能做的仅仅是在用户空间分配一块m的堆内存。在这个函数里没有涉及到线程相关操作。那为什么通常说m对应一个线程呢？原因在后面解释。

在runtime里，调用allocm函数的地方有两处：
```
+--------+       +----------------+
| newm() |       | oneNewExtraM() |
+-----+--+       +--+-------------+
      |             |
      +----+    +---+
           |    |
        +--v----v--+
        | allocm() |
        +-----+----+
              |
              v
          +---+----+
          | new(m) |
          +--------+
```

下面先看newm函数：
```go
// Create a new m. It will start off with a call to fn, or else the scheduler.
// fn needs to be static and not a heap allocated closure.
// May run with m.p==nil, so write barriers are not allowed.
//go:nowritebarrierrec
func newm(fn func(), _p_ *p) {
	mp := allocm(_p_, fn) // 详细过程见上面
	mp.nextp.set(_p_) // 这里为什么要把_p_放到mp.nextp上呢？TODO
	mp.sigmask = initSigmask
    ...
	newm1(mp)
}
```
```go
func newm1(mp *m) {
    ...
	execLock.rlock() // Prevent process clone.
	newosproc(mp) // 开始创建os线程
	execLock.runlock()
}
```
```go
// located at runtime/os_linux.go
// May run with m.p==nil, so write barriers are not allowed.
//go:nowritebarrier
func newosproc(mp *m) {
	stk := unsafe.Pointer(mp.g0.stack.hi) // 得到g0栈起始位置，说明新线程的用户栈就是g0的栈
    ...
	// Disable signals during clone, so that the new thread starts
	// with signals disabled. It will enable them in minit.
	var oset sigset
    sigprocmask(_SIG_SETMASK, &sigset_all, &oset)
    // 
	ret := clone(cloneFlags, stk, unsafe.Pointer(mp), unsafe.Pointer(mp.g0), unsafe.Pointer(funcPC(mstart)))
	sigprocmask(_SIG_SETMASK, &oset, nil)

	if ret < 0 {
		print("runtime: failed to create new OS thread (have ", mcount(), " already; errno=", -ret, ")\n")
		if ret == -_EAGAIN {
			println("runtime: may need to increase max user processes (ulimit -u)")
		}
		throw("newosproc")
	}
}
```
```go
// int32 clone(int32 flags, void *stk, M *mp, G *gp, void (*fn)(void));
TEXT runtime·clone(SB),NOSPLIT,$0
	MOVL	flags+0(FP), DI
	MOVQ	stk+8(FP), SI
	MOVQ	$0, DX
	MOVQ	$0, R10

	// Copy mp, gp, fn off parent stack for use by child.
	// Careful: Linux system call clobbers CX and R11.
	MOVQ	mp+16(FP), R8
	MOVQ	gp+24(FP), R9
	MOVQ	fn+32(FP), R12

	MOVL	$SYS_clone, AX // 系统调用号
	SYSCALL

	// In parent, return.
	CMPQ	AX, $0 // 如果返回值为0，是子进程返回了；如果非0，则是父进程返回了
	JEQ	3(PC)
	MOVL	AX, ret+40(FP) // 如果是父进程返回，直接将rax中的返回值（子进程的pid）放进ret变量中
	RET 

    // 注意下面的指令，只有子进程才会执行

	// In child, on new stack.
	MOVQ	SI, SP // 切换到子进程的栈上

    // If g or m are nil, skip Go-related setup.
    // 通过前面的分析可以知道可以知道，m和m.g0都有值
	CMPQ	R8, $0    // m
	JEQ	nog
	CMPQ	R9, $0    // g
	JEQ	nog

    // Initialize m->procid to Linux tid
    // 因为现在已经在子进程中了，所以只有通过系统调用的方式获得子进程的pid
	MOVL	$SYS_gettid, AX
	SYSCALL
	MOVQ	AX, m_procid(R8)

    // Set FS to point at m->tls.
    // 通过SYS_arch_prctl系统调用来设置m.tls为当前进程（线程）的tls
	LEAQ	m_tls(R8), DI
	CALL	runtime·settls(SB)

	// In child, set up new stack
	get_tls(CX)
	MOVQ	R8, g_m(R9) // g0.m = m
	MOVQ	R9, g(CX)   // 将g0设置为当前m正在运行的g
	CALL	runtime·stackcheck(SB)

nog:
	// Call fn
	CALL	R12   // 调用mstart函数，never return
    ...
```
在上面代码的分析中，在不同的语境下，我将线程与进程混用，这是可以的（参考内核书籍进程相关章节，如「ULK」）。另外，对plan9不熟悉的话，可以使用`objdump -d xxx | grep 'runtime.clone'`查看x86汇编，对照着看。关于settls函数的内容，参考我上一篇文章[Go程序启动源码分析](https://wuyang.me/2019/08/07/go%E7%A8%8B%E5%BA%8F%E5%90%AF%E5%8A%A8%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90.html)。

如果从内核的角度来看，父进程创建子进程后就回到了自己的control flow中。至于子进程什么时候被调度（mstart函数什么时候执行），那就要看内核的调度了，但是子进程迟早是会执行的。如果子进程被内核调度，回到用户空间执行的第一条语句就是`CMPQ	AX, $0`，由于rax（AX）= 0，所以下一条指令是`MOVQ	SI, SP`。

需要注意的是，runtime/proc.go里面有两个函数名字挺相近的函数，一个是mstart函数；另一个是startm函数。不要将二者弄混了。

现在，我们已经分析完newm函数了。再完善一下调用链：
```
+-----------------------+   +----------+   +--------+   +-------------------------+
| startTemplateThread() |   | startm() |   | main() |   | startTheWorldWithSema() |
+----------------+------+   ++---------+   +---+----+   +-------+-----------------+
                 |           |                 |                |
                 +---------+ | +---------------+                |
                           | | |  +-----------------------------+
                           v v v  v
                          ++-+-+--++       +----------------+
                          | newm() |       | oneNewExtraM() |
                          +-----+--+       +--+-------------+
                                |             |
                                +----+    +---+
                                     |    |
                                  +--v----v--+
                                  | allocm() |
                                  +-----+----+
                                        |
                                        v
                                    +---+----+
                                    | new(m) |
                                    +--------+
```



### 获得一个已有的m