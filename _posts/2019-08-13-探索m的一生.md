---
layout: post
title: '探索m的一生'
subtitle: ''
date: 2019-08-13
categories: 技术
cover: ''
tags: Golang
---

环境：
```go
$ go version
go version go1.12.7 linux/amd64
$ uname -a
Linux wu-insparition 4.18.0-25-generic #26~18.04.1-Ubuntu SMP Thu Jun 27 07:28:31 UTC 2019 x86_64 x86_64 x86_64 GNU/Linux
```

go调度的实现还是挺复杂的，从最简单的m切入再好不过了。

## 如何得到m
___

m是一个结构体，在runtime中分配一个m通常使用new关键字`new(m)`。整个runtime中唯一调用`new(m)`的地方，就是allocm函数：
```go
// Allocate a new m unassociated with any thread.
// Can use p for allocation context if needed.
// fn is recorded as the new m's m.mstartfn.
//
// This function is allowed to have write barriers even if the caller
// isn't because it borrows _p_.
//
//go:yeswritebarrierrec
func allocm(_p_ *p, fn func()) *m {
    // 通过tls得到当前线程正在运行的g
    // g还是g0，还不确定TODO
    // 但是看到获取_g_的目的都是在使用_g_.m（当前线程），所以无论是g还是g0，_g_.m都一样
	_g_ := getg() 
	_g_.m.locks++ // disable GC because it can be called from sysmon
	if _g_.m.p == 0 {
        // 如果当前线程没有p，就把为allocm函数准备的_p_
        // 暂时借给当前线程_g_.m
		acquirep(_p_) // temporarily borrow p for mallocs in this function
	}

	// Release the free M list. We need to do this somewhere and
	// this may free up a stack we can use.
	if sched.freem != nil {
		lock(&sched.lock)
		var newList *m
		for freem := sched.freem; freem != nil; {
			if freem.freeWait != 0 {
				next := freem.freelink
				freem.freelink = newList
				newList = freem
				freem = next
				continue
			}
			stackfree(freem.g0.stack)
			freem = freem.freelink
		}
		sched.freem = newList
		unlock(&sched.lock)
	}

	mp := new(m)
	mp.mstartfn = fn
	mcommoninit(mp)

	// In case of cgo or Solaris or Darwin, pthread_create will make us a stack.
	// Windows and Plan 9 will layout sched stack on OS stack.
	if iscgo || GOOS == "solaris" || GOOS == "windows" || GOOS == "plan9" || GOOS == "darwin" {
		mp.g0 = malg(-1)
	} else {
		mp.g0 = malg(8192 * sys.StackGuardMultiplier)
	}
	mp.g0.m = mp

	if _p_ == _g_.m.p.ptr() {
		releasep()
	}
	_g_.m.locks--
	if _g_.m.locks == 0 && _g_.preempt { // restore the preemption request in case we've cleared it in newstack
		_g_.stackguard0 = stackPreempt
	}

	return mp
}
```
注意这个函数的注释：创建一个没有与thread相关联的m，为什么？因为在allocm函数里，能做的仅仅是在用户空间分配一块m的堆内存。在这个函数里没有涉及到线程相关操作。那为什么通常说m对应一个线程呢？原因在后面解释。

创建m的唯一方式就是调用newm函数。newm函数接受一个function value和一个p的指针作为参数，没有返回值。整个runtime里，共有4处调用newm函数，分别是：
- func main()
- func startm(_p_ *p, spinning bool)
- func startTheWorldWithSema(emitTraceEvent bool) int64
- func startTemplateThread()
其中比较重要的是前两个函数。在main函数里：
```go
if GOARCH != "wasm" { // no threads on wasm yet, so no sysmon
	systemstack(func() {
		newm(sysmon, nil)
	})
}
```
创建一个m用来执行sysmon函数，注意第二个参数为nil。在
