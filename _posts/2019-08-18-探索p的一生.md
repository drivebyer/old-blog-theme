---
layout: post
title: '探索p的一生'
subtitle: 'p的初始化，p的状态切换'
date: 2019-08-18
categories: 技术
cover: ''
tags: Golang
---

环境：
```go
$ go version
go version go1.12.7 linux/amd64
$ uname -a
Linux wu-insparition 4.18.0-25-generic #26~18.04.1-Ubuntu SMP Thu Jun 27 07:28:31 UTC 2019 x86_64 x86_64 x86_64 GNU/Linux
```

与分析m的流程类似，首先从`new(p)`语句的调用开始。通过搜索源码，能总结出一个简单的调用链：
```
+-------------+     +-------------------------+
| schedinit() |     | startTheWorldWithSema() |
+-----------+-+     +--+----------------------+
            |          |
            v          v
          +-+----------+-+
          | procresize() |
          +------+-------+
                 |
                 v
             +---+----+
             | new(p) |
             +--------+
```
其中最重要的是[func procresize(nprocs int32) *p](https://github.com/golang/go/blob/master/src/runtime/proc.go#L3990)函数。这个函数的作用是改变系统中p的数量，由全局变量allp体现。主要流程如下：
- 将allp数组改变到参数（nprocs）指定大小
- 初始化allp中为nil的槽
    - 通过new(p)在堆上分配p结构体
    - 初始化状态为_Pgcstop（这里没懂为什么是这个初始状态？TODO）
    - 分配mcache成员
- 如果想要减少系统中p的数量
    - 如果有的话，把p.runq上的goroutine释放到全局队列sched.runq
    - 如果有的话，把p.runnext上的goroutine释放到全局队列sched.runq
    - 如果有的话，把p.gcBgMarkWorker上的goroutine释放到全局队列sched.runq
    - 释放p.mcache
    - 将_p_.gFree中的“死（_Gdead）”goroutine放进全局队列sched.gFree
    - 最后将p的状态置为_Pdead


