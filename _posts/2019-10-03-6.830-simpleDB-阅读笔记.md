---
layout: post
title: '6.830-SimpleDB阅读笔记'
subtitle: '未整理'
date: 2019-10-03
categories: 技术
cover: ''
tags: Kernel
---

HeapFile(Table): 
- A HeapFile object is arranged into a set of pages, each of which consists of a fixed number of bytes for storing tuples, (defined by the constant BufferPool.DEFAULT_PAGE_SIZE), including a header.
- In SimpleDB, there is one HeapFile object for each table in the database
- A catalog that stores information about available tables and their schemas
- Associated with each table is a TupleDesc object that allows operators to determine the types and number of fields in a table.
- SimpleDB stores heap files on disk in more or less the same format they are stored in memory.
- To read a page from disk, you will first need to calculate the correct offset in the file. 

HeapPage: 
- HeapPage consists of a fixed number of bytes for storing tuples, (defined by the constant BufferPool.DEFAULT_PAGE_SIZE), including a header.
- heapfile与heappage是一对多的关系，即一个table的数据多的话，可能有多个page
- Each page in a HeapFile is arranged as a set of slots, each of which can hold one tuple (tuples for a given table in SimpleDB are all of the same size).
- In addition to these slots, each page has a header that consists of a bitmap with one bit per tuple slot(因为一个Page大小固定，Page里Tuple大小也固定，所以Page里Tuple的数量也固定，所以bitmap的位数也固定). If the bit corresponding to a particular tuple is 1, it indicates that the tuple is valid; if it is 0, the tuple is invalid (e.g., has been deleted or was never initialized.)
- _tuples per page_ = floor((_page size_ * 8) / (_tuple size_ * 8 + 1))  The idea here is that each tuple requires one additional bit of storage in the header. The floor operation rounds down to the nearest integer number of tuples (we don't want to store partial tuples on a page!)
- To read a page from disk, you will first need to calculate the correct offset in the file. 

PageHeader：
- The low (least significant) bits of each byte represents the status of the slots that are earlier in the file. Hence, the lowest bit of the first byte represents whether or not the first slot in the page is in use. The second lowest bit of the first byte represents whether or not the second slot in the page is in use, and so on.

access method: 
- access methods (e.g., heap files) that store relations on disk and provide a way to iterate through tuples of those relations;
- `Tuple` objects are created by the underlying access methods (e.g., heap files, or B-trees)
- Common access methods include heap files (unsorted files of tuples) and B-trees

operator:
- A collection of operator classes (e.g., select, join, insert, delete, etc.) that process tuples
- Operators are responsible for the actual execution of the query plan. They implement the operations of the relational algebra. In SimpleDB, operators are iterator based; each operator implements the DbIterator interface.
- Operators are connected together into a plan by passing lower-level operators into the constructors of higher-level operators, i.e., by 'chaining them together.' Special access method operators at the leaves of the plan are responsible for reading data from the disk (and hence do not have any operators below them).

bufferpool
- A buffer pool that caches active tuples and pages in memory and handles concurrency control and transactions
- The buffer pool is responsible for caching pages in memory that have been recently read from disk. All operators read and write pages from various files on disk through the buffer pool. It consists of a fixed number of pages. 
- 

catalog:
- A catalog that stores information about all available tables and their schemas
- 

database:
- The Database class provides access to a collection of static objects that are the global state of the database. In particular, this includes methods to access the catalog (the list of all the tables in the database), the buffer pool (the collection of database file pages that are currently resident in memory), and the log file.
- 

Tuple:
- Tuple consist of a collection of `Field` objects, one per field in the `Tuple`.
- `Tuple` objects are created by the underlying access methods (e.g., heap files, or B-trees)
- Tuples also have a type (or schema), called a _tuple descriptor_, represented by a `TupleDesc` object.

TupleDesc:
- This object consists of a collection of `Type` objects, one per field in the tuple, each of which describes the type of the corresponding field.

Field
- `Field` is an interface that different data types (e.g., integer, string) implement.


query plan
- 1

Cost based optimizer
- https://www.programmerinterview.com/database-sql/what-is-cost-based-optimization/
- Use statistics about tables to estimate "costs" of different query plans.
- the cost of a plan is related to the cardinalities of (number of tuples produced by) intermediate joins and selections, as well as the selectivity of filter and join predicates.

Parser
- When the Parser is invoked, it will compute statistics over all of the tables (using statistics code you provide). When a query is issued, the parser will convert the query into a logical plan representation and then call your query optimizer to generate an optimal plan.

logical plan to physical plan : https://courses.cs.washington.edu/courses/cse344/15wi/sections/sec4-physical-plans.pdf

# 一、Operator Implement

...

# 二、Query Optimization

在SimpleDB中使用的的是cost-based optimizer，简称CBO。与CBO相对应的是RBO，这篇文章描述了二者的区别：[ORACLE优化器RBO与CBO介绍总结](https://www.cnblogs.com/kerrycode/p/3842215.html)。

CBO主要分为下面两个步骤：
- Use **statistics** about tables to estimate "costs" of different **query plans**. Typically, the cost of a plan is related to the cardinalities of (number of tuples produced by) intermediate **joins** and **selections**, as well as the selectivity of filter and join predicates.
- Use these statistics to **order** joins and selections in an optimal way, and to select the best implementation for join algorithms from amongst several alternatives.

下面是SimpleDB中optimizer的整体结构：
![simpleDB-optimizer.png](http://ww1.sinaimg.cn/large/c9caade4gy1g7n9i62oraj20su12gjx8.jpg)

## 2.1 Statistics Estimation

如果要对n张表执行Join：**p=t1 join t2 join t3 join ... tn**。这种情况下，可以用如下形式来表示整个操作的cost：

```c
scancost(t1) + scancost(t2) + joincost(t1 join t2) +
scancost(t3) + joincost((t1 join t2) join t3) +
... 
```

其中scancost(t1)是扫描整张表的I/O cost；joincost(t1 join t2)是t1与t2间的CPU cost。scancost我们很容易理解，但是joincost该如何理解呢？

据我所知，实现Join的算法有两种：
- One-pass join：更能优化磁盘I/O
- Nested-loop join：更能优化内存使用

在SimpleDB中使用Nested-loop join算法，可以得出下面这个公式：

```c
joincost(t1 join t2) = scancost(t1) + ntups(t1) x scancost(t2) //IO cost
                       + ntups(t1) x ntups(t2)  //CPU cost
```

## 2.2 Join Ordering

...

# 三、Transaction

- track the locks held by each transaction
- grant locks to transactions as they are needed

在SimpleDB中，为了简化工作量，使用了NO STEAL/FORCE buffer management policy：
- NO STEAL：You shouldn't evict dirty (updated) pages from the buffer pool if they are locked by an uncommitted transaction ---> **never need undo（取消错误的操作）**
- FORCE：On transaction commit, you should force dirty pages to disk ---> **never need redo（重做正确的操作）**

在SimpleDB中，使用了Page粒度锁（当然也可以自行实现Tuple粒度锁，但绝不能使用Table粒度锁）。

参考资料：
- https://github.com/MIT-DB-Class/course-info-2018
- [ORACLE优化器RBO与CBO介绍总结](https://www.cnblogs.com/kerrycode/p/3842215.html)