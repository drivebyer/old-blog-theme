---
layout: post
title: 'Go语言规范[译]'
subtitle: ''
date: 2019-10-16
categories: 技术
cover: ''
tags: Golang
---

> 本文译自[The Go Programming Language Specification](https://golang.org/ref/spec#Introduction)。

翻译仅为学习使用，不准确的地方还请谅解。

# 1、Introduction

本文是Go编程语言的参考手册（reference manual），如想了解更多的信息和文档，请参考[golang.org](https://golang.org/)。

Go是一门通用目的型（general-purpose）语言，它的设计始终都是为了系统编程。它有强类型（strongly typed）、自带垃圾收集（garbage-collected）、显示的支持并发编程等特点。程序（programs）由包（packages）构成，这种性质可以有效的帮助依赖管理（management of dependencies）。

Go的语法非常紧凑（compact）和规范（regular）。它还自带一些自动化分析工具（对分析程序性能非常友好）。

# 2、Notation

Go的句法（syntax）使用了[扩展巴科斯-瑙尔范式](https://zh.wikipedia.org/wiki/%E6%89%A9%E5%B1%95%E5%B7%B4%E7%A7%91%E6%96%AF%E8%8C%83%E5%BC%8F)。

```go
Production  = production_name "=" [ Expression ] "." .
Expression  = Alternative { "|" Alternative } .
Alternative = Term { Term } .
Term        = production_name | token [ "…" token ] | Group | Option | Repetition .
Group       = "(" Expression ")" .
Option      = "[" Expression "]" .
Repetition  = "{" Expression "}" .
```

产生式（production）是一种表达式（expression），由**term**和**operator**构成，按照下面的优先级：

```go
|   alternation
()  grouping
[]  option (0 or 1 times)
{}  repetition (0 to n times)
```

通常用全小写（lower-case）的产生式（production）来标记**lexical token**。Non-terminal则使用驼峰形式（CamelCase）。Lexical token被双引号或者单引号包括（enclose）。

形如**a … b**表示从a到b到字符是可选的。注意 **…** 这个字符和 **...** 的区别，前者不能当作Go语言中的token。

# 3、Source code representation

源码是使用UTF-8编码的Unicode文本。文本（text）不是规范化（canonicalized）的，因此一个单独的**accented code point**与一个**accent**和**letter**组成的**charater**不是一码事。一个单独的**accented code point**被当作两个**code point**。为了简便，本片文档将会使用不太准确的**term character**来类比源码文本中的**Unicode code point**。

每个**code point**都是不同的；比方说，大写A和小写a是两个不同的字符（character）。

实现限制：为了与其他工具兼容，Go的编译器不允许在源码文本（source text）中出现**NUL**字符。

实现限制：为了与其他工具兼容，Go的编译器碰到源码文本（source text）中的第一个**code point**为[byte order mark](https://en.wikipedia.org/wiki/Byte_order_mark)时，编译器会选择忽略它。除此之外，**byte order mark**不允许出现在源码文本中的其他任何地方。

## 3.1、Characters

使用下面的术语来表示一个特定的**Unicode**字符类别：

```go
newline        = /* the Unicode code point U+000A */ .
unicode_char   = /* an arbitrary Unicode code point except newline */ .
unicode_letter = /* a Unicode code point classified as "Letter" */ .
unicode_digit  = /* a Unicode code point classified as "Number, decimal digit" */ .
```

在[The Unicode Standard 8.0](https://www.unicode.org/versions/Unicode8.0.0/)的第4.5节中，定义了一个字符类别集合，Go把Lu, Ll, Lt, Lm, or Lo这些种类中的所有字符（character）都当作**Unicode letter**，把Nd种类下的都当作**Unicode digit**。

## 3.2、Letters and digits

在Go中，下划线**_**被当作是一个字母（letter）。

```go
letter        = unicode_letter | "_" .
decimal_digit = "0" … "9" .
binary_digit  = "0" | "1" .
octal_digit   = "0" … "7" .
hex_digit     = "0" … "9" | "A" … "F" | "a" … "f" .
```

# 4、Lexical elements

## 4.1、Comments

Comment可以用来写程序文档，Comment有下面两种形式：
- Line comments：形如//
- General comments：形如/**/

rune、string literal和comment中不能包含comment。没有**newline**的comment表现得像一个空格。其他任何comment表现得像一个newline。

## 4.2、Tokens

Tokens form the vocabulary of the Go language. There are four classes: identifiers, keywords, operators and punctuation, and literals. White space, formed from spaces (U+0020), horizontal tabs (U+0009), carriage returns (U+000D), and newlines (U+000A), is ignored except as it separates tokens that would otherwise combine into a single token. Also, a newline or end of file may trigger the insertion of a semicolon. While breaking the input into tokens, the next token is the longest sequence of characters that form a valid token.

**Token**组成了Go语言的词汇表（vocabulary）。有下面4个种类的**token**：
- identifier
- keyword
- operator and punctuation
- literal

后面会一一介绍。

White space可以由下面四种Unicode组成：
- spaces (U+0020)
- horizontal tabs (U+0009)
- carriage returns (U+000D)
- newlines (U+000A)

一般会忽略White space，除非它将一个token分离成了两个token。

通常来说一旦遇到newline或是EOF，会自动加上一个semicolon（分号）。

当把输入拆分成**token**时，下一个token是组成有效token当最长字符序列。

## 4.3、Semicolons

通常来说，在一系列production后接上一个分号标志着结束，在Go里面却没有采取这种语法，因为下面两条规则：

### 4.3.1、rule one

当输入被拆分成token，自动将一个分号插入到一行到最后一个token后面，这个最后到token必须是以下几种情况：
- identifier
- integer, floating-point, imaginary, rune, or string literal
- break, continue, fallthrough, or return等关键字
- ++, --, ), ], or }等运算符和标点

### 4.3.1、rule two

为了在一行中能够使用复杂等语句，**)** 或者 **}** 前的分号也可以省略

## 4.4、Identifiers

Identifier（标识符）用来命名程序中的变量和类型。Identifier由一个或者多个**letter**和**digit**组成，第一个字符必须是letter（译注：回忆前面说过，下划线 _ 也是letter，在后面会看到，这种标识符被称为**blank identifier**）。

```go
identifier = letter { letter | unicode_digit } .
```
```go
a
_x9
ThisVariableIsExported
αβ
```

有些identifier是预定义的（译注：留意后面Predeclared identifiers小节）。

## 4.5、Keywords
## 4.6、Operators and punctuation
## 4.7、Integer literals
## 4.8、Floating-point literals
## 4.9、Imaginary literals
## 4.10、Rune literals
## 4.11、String literals
# 5、Constants
# 6、Variables
# 7、Types
Method sets
Boolean types
Numeric types
String types
Array types
Slice types
Struct types
Pointer types
Function types
Interface types
Map types
Channel types
Properties of types and values
Type identity
Assignability
Representability
Blocks
Declarations and scope
Label scopes
Blank identifier
Predeclared identifiers
Exported identifiers
Uniqueness of identifiers
Constant declarations
Iota
Type declarations
Variable declarations
Short variable declarations
Function declarations
Method declarations
Expressions
Operands
Qualified identifiers
Composite literals
Function literals
Primary expressions
Selectors
Method expressions
Method values
Index expressions
Slice expressions
Type assertions
Calls
Passing arguments to ... parameters
Operators
Arithmetic operators
Comparison operators
Logical operators
Address operators
Receive operator
Conversions
Constant expressions
Order of evaluation
Statements
Terminating statements
Empty statements
Labeled statements
Expression statements
Send statements
IncDec statements
Assignments
If statements
Switch statements
For statements
Go statements
Select statements
Return statements
Break statements
Continue statements
Goto statements
Fallthrough statements
Defer statements
Built-in functions
Close
Length and capacity
Allocation
Making slices, maps and channels
Appending to and copying slices
Deletion of map elements
Manipulating complex numbers
Handling panics
Bootstrapping
Packages
Source file organization
Package clause
Import declarations
An example package
Program initialization and execution
The zero value
Package initialization
Program execution
Errors
Run-time panics
System considerations
Package unsafe
Size and alignment guarantees